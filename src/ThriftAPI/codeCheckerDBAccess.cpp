/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "codeCheckerDBAccess.h"




codeCheckerDBAccess_getRunData_args::~codeCheckerDBAccess_getRunData_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->runFilter.read(iprot);
          this->__isset.runFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunData_args");

  xfer += oprot->writeFieldBegin("runFilter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->runFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunData_pargs::~codeCheckerDBAccess_getRunData_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunData_pargs");

  xfer += oprot->writeFieldBegin("runFilter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->runFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunData_result::~codeCheckerDBAccess_getRunData_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            this->success.resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += this->success[_i211].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<RunData> ::const_iterator _iter212;
      for (_iter212 = this->success.begin(); _iter212 != this->success.end(); ++_iter212)
      {
        xfer += (*_iter212).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunData_presult::~codeCheckerDBAccess_getRunData_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readListBegin(_etype216, _size213);
            (*(this->success)).resize(_size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              xfer += (*(this->success))[_i217].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getRunCount_args::~codeCheckerDBAccess_getRunCount_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunCount_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->runFilter.read(iprot);
          this->__isset.runFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunCount_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunCount_args");

  xfer += oprot->writeFieldBegin("runFilter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->runFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunCount_pargs::~codeCheckerDBAccess_getRunCount_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunCount_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunCount_pargs");

  xfer += oprot->writeFieldBegin("runFilter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->runFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunCount_result::~codeCheckerDBAccess_getRunCount_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunCount_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunCount_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunCount_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunCount_presult::~codeCheckerDBAccess_getRunCount_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunCount_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getCheckCommand_args::~codeCheckerDBAccess_getCheckCommand_args() throw() {
}


uint32_t codeCheckerDBAccess_getCheckCommand_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->runHistoryId);
          this->__isset.runHistoryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->runId);
          this->__isset.runId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckCommand_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckCommand_args");

  xfer += oprot->writeFieldBegin("runHistoryId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->runHistoryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->runId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckCommand_pargs::~codeCheckerDBAccess_getCheckCommand_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getCheckCommand_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckCommand_pargs");

  xfer += oprot->writeFieldBegin("runHistoryId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->runHistoryId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->runId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckCommand_result::~codeCheckerDBAccess_getCheckCommand_result() throw() {
}


uint32_t codeCheckerDBAccess_getCheckCommand_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckCommand_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckCommand_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckCommand_presult::~codeCheckerDBAccess_getCheckCommand_presult() throw() {
}


uint32_t codeCheckerDBAccess_getCheckCommand_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getRunHistory_args::~codeCheckerDBAccess_getRunHistory_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistory_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size218;
            ::apache::thrift::protocol::TType _etype221;
            xfer += iprot->readListBegin(_etype221, _size218);
            this->runIds.resize(_size218);
            uint32_t _i222;
            for (_i222 = 0; _i222 < _size218; ++_i222)
            {
              xfer += iprot->readI64(this->runIds[_i222]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->runHistoryFilter.read(iprot);
          this->__isset.runHistoryFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunHistory_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistory_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter223;
    for (_iter223 = this->runIds.begin(); _iter223 != this->runIds.end(); ++_iter223)
    {
      xfer += oprot->writeI64((*_iter223));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runHistoryFilter", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->runHistoryFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistory_pargs::~codeCheckerDBAccess_getRunHistory_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistory_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistory_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter224;
    for (_iter224 = (*(this->runIds)).begin(); _iter224 != (*(this->runIds)).end(); ++_iter224)
    {
      xfer += oprot->writeI64((*_iter224));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runHistoryFilter", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->runHistoryFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistory_result::~codeCheckerDBAccess_getRunHistory_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistory_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size225;
            ::apache::thrift::protocol::TType _etype228;
            xfer += iprot->readListBegin(_etype228, _size225);
            this->success.resize(_size225);
            uint32_t _i229;
            for (_i229 = 0; _i229 < _size225; ++_i229)
            {
              xfer += this->success[_i229].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunHistory_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistory_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<RunHistoryData> ::const_iterator _iter230;
      for (_iter230 = this->success.begin(); _iter230 != this->success.end(); ++_iter230)
      {
        xfer += (*_iter230).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistory_presult::~codeCheckerDBAccess_getRunHistory_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistory_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size231;
            ::apache::thrift::protocol::TType _etype234;
            xfer += iprot->readListBegin(_etype234, _size231);
            (*(this->success)).resize(_size231);
            uint32_t _i235;
            for (_i235 = 0; _i235 < _size231; ++_i235)
            {
              xfer += (*(this->success))[_i235].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getRunHistoryCount_args::~codeCheckerDBAccess_getRunHistoryCount_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryCount_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size236;
            ::apache::thrift::protocol::TType _etype239;
            xfer += iprot->readListBegin(_etype239, _size236);
            this->runIds.resize(_size236);
            uint32_t _i240;
            for (_i240 = 0; _i240 < _size236; ++_i240)
            {
              xfer += iprot->readI64(this->runIds[_i240]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->runHistoryFilter.read(iprot);
          this->__isset.runHistoryFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunHistoryCount_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistoryCount_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter241;
    for (_iter241 = this->runIds.begin(); _iter241 != this->runIds.end(); ++_iter241)
    {
      xfer += oprot->writeI64((*_iter241));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runHistoryFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->runHistoryFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistoryCount_pargs::~codeCheckerDBAccess_getRunHistoryCount_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryCount_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistoryCount_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter242;
    for (_iter242 = (*(this->runIds)).begin(); _iter242 != (*(this->runIds)).end(); ++_iter242)
    {
      xfer += oprot->writeI64((*_iter242));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runHistoryFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->runHistoryFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistoryCount_result::~codeCheckerDBAccess_getRunHistoryCount_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryCount_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunHistoryCount_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistoryCount_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistoryCount_presult::~codeCheckerDBAccess_getRunHistoryCount_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryCount_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getDiffResultsHash_args::~codeCheckerDBAccess_getDiffResultsHash_args() throw() {
}


uint32_t codeCheckerDBAccess_getDiffResultsHash_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size243;
            ::apache::thrift::protocol::TType _etype246;
            xfer += iprot->readListBegin(_etype246, _size243);
            this->runIds.resize(_size243);
            uint32_t _i247;
            for (_i247 = 0; _i247 < _size243; ++_i247)
            {
              xfer += iprot->readI64(this->runIds[_i247]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reportHashes.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _etype251;
            xfer += iprot->readListBegin(_etype251, _size248);
            this->reportHashes.resize(_size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              xfer += iprot->readString(this->reportHashes[_i252]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.reportHashes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast253;
          xfer += iprot->readI32(ecast253);
          this->diffType = (DiffType::type)ecast253;
          this->__isset.diffType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skipDetectionStatuses.clear();
            uint32_t _size254;
            ::apache::thrift::protocol::TType _etype257;
            xfer += iprot->readListBegin(_etype257, _size254);
            this->skipDetectionStatuses.resize(_size254);
            uint32_t _i258;
            for (_i258 = 0; _i258 < _size254; ++_i258)
            {
              int32_t ecast259;
              xfer += iprot->readI32(ecast259);
              this->skipDetectionStatuses[_i258] = (DetectionStatus::type)ecast259;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skipDetectionStatuses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getDiffResultsHash_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getDiffResultsHash_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter260;
    for (_iter260 = this->runIds.begin(); _iter260 != this->runIds.end(); ++_iter260)
    {
      xfer += oprot->writeI64((*_iter260));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportHashes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->reportHashes.size()));
    std::vector<std::string> ::const_iterator _iter261;
    for (_iter261 = this->reportHashes.begin(); _iter261 != this->reportHashes.end(); ++_iter261)
    {
      xfer += oprot->writeString((*_iter261));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("diffType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->diffType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skipDetectionStatuses", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->skipDetectionStatuses.size()));
    std::vector<DetectionStatus::type> ::const_iterator _iter262;
    for (_iter262 = this->skipDetectionStatuses.begin(); _iter262 != this->skipDetectionStatuses.end(); ++_iter262)
    {
      xfer += oprot->writeI32((int32_t)(*_iter262));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getDiffResultsHash_pargs::~codeCheckerDBAccess_getDiffResultsHash_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getDiffResultsHash_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getDiffResultsHash_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter263;
    for (_iter263 = (*(this->runIds)).begin(); _iter263 != (*(this->runIds)).end(); ++_iter263)
    {
      xfer += oprot->writeI64((*_iter263));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportHashes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->reportHashes)).size()));
    std::vector<std::string> ::const_iterator _iter264;
    for (_iter264 = (*(this->reportHashes)).begin(); _iter264 != (*(this->reportHashes)).end(); ++_iter264)
    {
      xfer += oprot->writeString((*_iter264));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("diffType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->diffType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skipDetectionStatuses", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->skipDetectionStatuses)).size()));
    std::vector<DetectionStatus::type> ::const_iterator _iter265;
    for (_iter265 = (*(this->skipDetectionStatuses)).begin(); _iter265 != (*(this->skipDetectionStatuses)).end(); ++_iter265)
    {
      xfer += oprot->writeI32((int32_t)(*_iter265));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getDiffResultsHash_result::~codeCheckerDBAccess_getDiffResultsHash_result() throw() {
}


uint32_t codeCheckerDBAccess_getDiffResultsHash_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _etype269;
            xfer += iprot->readListBegin(_etype269, _size266);
            this->success.resize(_size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              xfer += iprot->readString(this->success[_i270]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getDiffResultsHash_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getDiffResultsHash_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter271;
      for (_iter271 = this->success.begin(); _iter271 != this->success.end(); ++_iter271)
      {
        xfer += oprot->writeString((*_iter271));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getDiffResultsHash_presult::~codeCheckerDBAccess_getDiffResultsHash_presult() throw() {
}


uint32_t codeCheckerDBAccess_getDiffResultsHash_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _etype275;
            xfer += iprot->readListBegin(_etype275, _size272);
            (*(this->success)).resize(_size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              xfer += iprot->readString((*(this->success))[_i276]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getReport_args::~codeCheckerDBAccess_getReport_args() throw() {
}


uint32_t codeCheckerDBAccess_getReport_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportId);
          this->__isset.reportId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getReport_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReport_args");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->reportId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReport_pargs::~codeCheckerDBAccess_getReport_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getReport_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReport_pargs");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->reportId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReport_result::~codeCheckerDBAccess_getReport_result() throw() {
}


uint32_t codeCheckerDBAccess_getReport_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getReport_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReport_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReport_presult::~codeCheckerDBAccess_getReport_presult() throw() {
}


uint32_t codeCheckerDBAccess_getReport_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getRunResults_args::~codeCheckerDBAccess_getRunResults_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunResults_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size277;
            ::apache::thrift::protocol::TType _etype280;
            xfer += iprot->readListBegin(_etype280, _size277);
            this->runIds.resize(_size277);
            uint32_t _i281;
            for (_i281 = 0; _i281 < _size277; ++_i281)
            {
              xfer += iprot->readI64(this->runIds[_i281]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sortType.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _etype285;
            xfer += iprot->readListBegin(_etype285, _size282);
            this->sortType.resize(_size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              xfer += this->sortType[_i286].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sortType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getDetails);
          this->__isset.getDetails = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunResults_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunResults_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter287;
    for (_iter287 = this->runIds.begin(); _iter287 != this->runIds.end(); ++_iter287)
    {
      xfer += oprot->writeI64((*_iter287));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sortType.size()));
    std::vector<SortMode> ::const_iterator _iter288;
    for (_iter288 = this->sortType.begin(); _iter288 != this->sortType.end(); ++_iter288)
    {
      xfer += (*_iter288).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("getDetails", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->getDetails);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunResults_pargs::~codeCheckerDBAccess_getRunResults_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunResults_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunResults_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter289;
    for (_iter289 = (*(this->runIds)).begin(); _iter289 != (*(this->runIds)).end(); ++_iter289)
    {
      xfer += oprot->writeI64((*_iter289));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->sortType)).size()));
    std::vector<SortMode> ::const_iterator _iter290;
    for (_iter290 = (*(this->sortType)).begin(); _iter290 != (*(this->sortType)).end(); ++_iter290)
    {
      xfer += (*_iter290).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("getDetails", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool((*(this->getDetails)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunResults_result::~codeCheckerDBAccess_getRunResults_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunResults_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size291;
            ::apache::thrift::protocol::TType _etype294;
            xfer += iprot->readListBegin(_etype294, _size291);
            this->success.resize(_size291);
            uint32_t _i295;
            for (_i295 = 0; _i295 < _size291; ++_i295)
            {
              xfer += this->success[_i295].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunResults_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunResults_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ReportData> ::const_iterator _iter296;
      for (_iter296 = this->success.begin(); _iter296 != this->success.end(); ++_iter296)
      {
        xfer += (*_iter296).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunResults_presult::~codeCheckerDBAccess_getRunResults_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunResults_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            (*(this->success)).resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += (*(this->success))[_i301].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getRunReportCounts_args::~codeCheckerDBAccess_getRunReportCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunReportCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size302;
            ::apache::thrift::protocol::TType _etype305;
            xfer += iprot->readListBegin(_etype305, _size302);
            this->runIds.resize(_size302);
            uint32_t _i306;
            for (_i306 = 0; _i306 < _size302; ++_i306)
            {
              xfer += iprot->readI64(this->runIds[_i306]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunReportCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunReportCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter307;
    for (_iter307 = this->runIds.begin(); _iter307 != this->runIds.end(); ++_iter307)
    {
      xfer += oprot->writeI64((*_iter307));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunReportCounts_pargs::~codeCheckerDBAccess_getRunReportCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunReportCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunReportCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter308;
    for (_iter308 = (*(this->runIds)).begin(); _iter308 != (*(this->runIds)).end(); ++_iter308)
    {
      xfer += oprot->writeI64((*_iter308));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunReportCounts_result::~codeCheckerDBAccess_getRunReportCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunReportCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size309;
            ::apache::thrift::protocol::TType _etype312;
            xfer += iprot->readListBegin(_etype312, _size309);
            this->success.resize(_size309);
            uint32_t _i313;
            for (_i313 = 0; _i313 < _size309; ++_i313)
            {
              xfer += this->success[_i313].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunReportCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunReportCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<RunReportCount> ::const_iterator _iter314;
      for (_iter314 = this->success.begin(); _iter314 != this->success.end(); ++_iter314)
      {
        xfer += (*_iter314).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunReportCounts_presult::~codeCheckerDBAccess_getRunReportCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunReportCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size315;
            ::apache::thrift::protocol::TType _etype318;
            xfer += iprot->readListBegin(_etype318, _size315);
            (*(this->success)).resize(_size315);
            uint32_t _i319;
            for (_i319 = 0; _i319 < _size315; ++_i319)
            {
              xfer += (*(this->success))[_i319].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getRunResultCount_args::~codeCheckerDBAccess_getRunResultCount_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunResultCount_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size320;
            ::apache::thrift::protocol::TType _etype323;
            xfer += iprot->readListBegin(_etype323, _size320);
            this->runIds.resize(_size320);
            uint32_t _i324;
            for (_i324 = 0; _i324 < _size320; ++_i324)
            {
              xfer += iprot->readI64(this->runIds[_i324]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunResultCount_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunResultCount_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter325;
    for (_iter325 = this->runIds.begin(); _iter325 != this->runIds.end(); ++_iter325)
    {
      xfer += oprot->writeI64((*_iter325));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunResultCount_pargs::~codeCheckerDBAccess_getRunResultCount_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunResultCount_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunResultCount_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter326;
    for (_iter326 = (*(this->runIds)).begin(); _iter326 != (*(this->runIds)).end(); ++_iter326)
    {
      xfer += oprot->writeI64((*_iter326));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunResultCount_result::~codeCheckerDBAccess_getRunResultCount_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunResultCount_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunResultCount_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunResultCount_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunResultCount_presult::~codeCheckerDBAccess_getRunResultCount_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunResultCount_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getReportDetails_args::~codeCheckerDBAccess_getReportDetails_args() throw() {
}


uint32_t codeCheckerDBAccess_getReportDetails_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportId);
          this->__isset.reportId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getReportDetails_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReportDetails_args");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->reportId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReportDetails_pargs::~codeCheckerDBAccess_getReportDetails_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getReportDetails_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReportDetails_pargs");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->reportId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReportDetails_result::~codeCheckerDBAccess_getReportDetails_result() throw() {
}


uint32_t codeCheckerDBAccess_getReportDetails_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getReportDetails_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReportDetails_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReportDetails_presult::~codeCheckerDBAccess_getReportDetails_presult() throw() {
}


uint32_t codeCheckerDBAccess_getReportDetails_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getSourceFileData_args::~codeCheckerDBAccess_getSourceFileData_args() throw() {
}


uint32_t codeCheckerDBAccess_getSourceFileData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fileId);
          this->__isset.fileId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->fileContent);
          this->__isset.fileContent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast327;
          xfer += iprot->readI32(ecast327);
          this->encoding = (Encoding::type)ecast327;
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSourceFileData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSourceFileData_args");

  xfer += oprot->writeFieldBegin("fileId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->fileId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fileContent", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->fileContent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSourceFileData_pargs::~codeCheckerDBAccess_getSourceFileData_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getSourceFileData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSourceFileData_pargs");

  xfer += oprot->writeFieldBegin("fileId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->fileId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fileContent", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->fileContent)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->encoding)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSourceFileData_result::~codeCheckerDBAccess_getSourceFileData_result() throw() {
}


uint32_t codeCheckerDBAccess_getSourceFileData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSourceFileData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSourceFileData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSourceFileData_presult::~codeCheckerDBAccess_getSourceFileData_presult() throw() {
}


uint32_t codeCheckerDBAccess_getSourceFileData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getLinesInSourceFileContents_args::~codeCheckerDBAccess_getLinesInSourceFileContents_args() throw() {
}


uint32_t codeCheckerDBAccess_getLinesInSourceFileContents_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->linesInFilesRequested.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _etype331;
            xfer += iprot->readListBegin(_etype331, _size328);
            this->linesInFilesRequested.resize(_size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              xfer += this->linesInFilesRequested[_i332].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.linesInFilesRequested = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast333;
          xfer += iprot->readI32(ecast333);
          this->encoding = (Encoding::type)ecast333;
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getLinesInSourceFileContents_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getLinesInSourceFileContents_args");

  xfer += oprot->writeFieldBegin("linesInFilesRequested", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->linesInFilesRequested.size()));
    std::vector<LinesInFilesRequested> ::const_iterator _iter334;
    for (_iter334 = this->linesInFilesRequested.begin(); _iter334 != this->linesInFilesRequested.end(); ++_iter334)
    {
      xfer += (*_iter334).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getLinesInSourceFileContents_pargs::~codeCheckerDBAccess_getLinesInSourceFileContents_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getLinesInSourceFileContents_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getLinesInSourceFileContents_pargs");

  xfer += oprot->writeFieldBegin("linesInFilesRequested", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->linesInFilesRequested)).size()));
    std::vector<LinesInFilesRequested> ::const_iterator _iter335;
    for (_iter335 = (*(this->linesInFilesRequested)).begin(); _iter335 != (*(this->linesInFilesRequested)).end(); ++_iter335)
    {
      xfer += (*_iter335).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->encoding)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getLinesInSourceFileContents_result::~codeCheckerDBAccess_getLinesInSourceFileContents_result() throw() {
}


uint32_t codeCheckerDBAccess_getLinesInSourceFileContents_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size336;
            ::apache::thrift::protocol::TType _ktype337;
            ::apache::thrift::protocol::TType _vtype338;
            xfer += iprot->readMapBegin(_ktype337, _vtype338, _size336);
            uint32_t _i340;
            for (_i340 = 0; _i340 < _size336; ++_i340)
            {
              int64_t _key341;
              xfer += iprot->readI64(_key341);
              std::map<int64_t, std::string> & _val342 = this->success[_key341];
              {
                _val342.clear();
                uint32_t _size343;
                ::apache::thrift::protocol::TType _ktype344;
                ::apache::thrift::protocol::TType _vtype345;
                xfer += iprot->readMapBegin(_ktype344, _vtype345, _size343);
                uint32_t _i347;
                for (_i347 = 0; _i347 < _size343; ++_i347)
                {
                  int64_t _key348;
                  xfer += iprot->readI64(_key348);
                  std::string& _val349 = _val342[_key348];
                  xfer += iprot->readString(_val349);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getLinesInSourceFileContents_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getLinesInSourceFileContents_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<int64_t, std::map<int64_t, std::string> > ::const_iterator _iter350;
      for (_iter350 = this->success.begin(); _iter350 != this->success.end(); ++_iter350)
      {
        xfer += oprot->writeI64(_iter350->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter350->second.size()));
          std::map<int64_t, std::string> ::const_iterator _iter351;
          for (_iter351 = _iter350->second.begin(); _iter351 != _iter350->second.end(); ++_iter351)
          {
            xfer += oprot->writeI64(_iter351->first);
            xfer += oprot->writeString(_iter351->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getLinesInSourceFileContents_presult::~codeCheckerDBAccess_getLinesInSourceFileContents_presult() throw() {
}


uint32_t codeCheckerDBAccess_getLinesInSourceFileContents_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size352;
            ::apache::thrift::protocol::TType _ktype353;
            ::apache::thrift::protocol::TType _vtype354;
            xfer += iprot->readMapBegin(_ktype353, _vtype354, _size352);
            uint32_t _i356;
            for (_i356 = 0; _i356 < _size352; ++_i356)
            {
              int64_t _key357;
              xfer += iprot->readI64(_key357);
              std::map<int64_t, std::string> & _val358 = (*(this->success))[_key357];
              {
                _val358.clear();
                uint32_t _size359;
                ::apache::thrift::protocol::TType _ktype360;
                ::apache::thrift::protocol::TType _vtype361;
                xfer += iprot->readMapBegin(_ktype360, _vtype361, _size359);
                uint32_t _i363;
                for (_i363 = 0; _i363 < _size359; ++_i363)
                {
                  int64_t _key364;
                  xfer += iprot->readI64(_key364);
                  std::string& _val365 = _val358[_key364];
                  xfer += iprot->readString(_val365);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_isReviewStatusChangeDisabled_args::~codeCheckerDBAccess_isReviewStatusChangeDisabled_args() throw() {
}


uint32_t codeCheckerDBAccess_isReviewStatusChangeDisabled_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_isReviewStatusChangeDisabled_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_isReviewStatusChangeDisabled_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_isReviewStatusChangeDisabled_pargs::~codeCheckerDBAccess_isReviewStatusChangeDisabled_pargs() throw() {
}


uint32_t codeCheckerDBAccess_isReviewStatusChangeDisabled_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_isReviewStatusChangeDisabled_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_isReviewStatusChangeDisabled_result::~codeCheckerDBAccess_isReviewStatusChangeDisabled_result() throw() {
}


uint32_t codeCheckerDBAccess_isReviewStatusChangeDisabled_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_isReviewStatusChangeDisabled_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_isReviewStatusChangeDisabled_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_isReviewStatusChangeDisabled_presult::~codeCheckerDBAccess_isReviewStatusChangeDisabled_presult() throw() {
}


uint32_t codeCheckerDBAccess_isReviewStatusChangeDisabled_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_changeReviewStatus_args::~codeCheckerDBAccess_changeReviewStatus_args() throw() {
}


uint32_t codeCheckerDBAccess_changeReviewStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportId);
          this->__isset.reportId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast366;
          xfer += iprot->readI32(ecast366);
          this->status = (ReviewStatus::type)ecast366;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_changeReviewStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_changeReviewStatus_args");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->reportId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_changeReviewStatus_pargs::~codeCheckerDBAccess_changeReviewStatus_pargs() throw() {
}


uint32_t codeCheckerDBAccess_changeReviewStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_changeReviewStatus_pargs");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->reportId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->status)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->message)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_changeReviewStatus_result::~codeCheckerDBAccess_changeReviewStatus_result() throw() {
}


uint32_t codeCheckerDBAccess_changeReviewStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_changeReviewStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_changeReviewStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_changeReviewStatus_presult::~codeCheckerDBAccess_changeReviewStatus_presult() throw() {
}


uint32_t codeCheckerDBAccess_changeReviewStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getComments_args::~codeCheckerDBAccess_getComments_args() throw() {
}


uint32_t codeCheckerDBAccess_getComments_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportId);
          this->__isset.reportId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getComments_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getComments_args");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->reportId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getComments_pargs::~codeCheckerDBAccess_getComments_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getComments_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getComments_pargs");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->reportId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getComments_result::~codeCheckerDBAccess_getComments_result() throw() {
}


uint32_t codeCheckerDBAccess_getComments_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size367;
            ::apache::thrift::protocol::TType _etype370;
            xfer += iprot->readListBegin(_etype370, _size367);
            this->success.resize(_size367);
            uint32_t _i371;
            for (_i371 = 0; _i371 < _size367; ++_i371)
            {
              xfer += this->success[_i371].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getComments_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getComments_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<CommentData> ::const_iterator _iter372;
      for (_iter372 = this->success.begin(); _iter372 != this->success.end(); ++_iter372)
      {
        xfer += (*_iter372).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getComments_presult::~codeCheckerDBAccess_getComments_presult() throw() {
}


uint32_t codeCheckerDBAccess_getComments_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _etype376;
            xfer += iprot->readListBegin(_etype376, _size373);
            (*(this->success)).resize(_size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              xfer += (*(this->success))[_i377].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getCommentCount_args::~codeCheckerDBAccess_getCommentCount_args() throw() {
}


uint32_t codeCheckerDBAccess_getCommentCount_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportId);
          this->__isset.reportId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCommentCount_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCommentCount_args");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->reportId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCommentCount_pargs::~codeCheckerDBAccess_getCommentCount_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getCommentCount_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCommentCount_pargs");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->reportId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCommentCount_result::~codeCheckerDBAccess_getCommentCount_result() throw() {
}


uint32_t codeCheckerDBAccess_getCommentCount_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCommentCount_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCommentCount_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCommentCount_presult::~codeCheckerDBAccess_getCommentCount_presult() throw() {
}


uint32_t codeCheckerDBAccess_getCommentCount_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_addComment_args::~codeCheckerDBAccess_addComment_args() throw() {
}


uint32_t codeCheckerDBAccess_addComment_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportId);
          this->__isset.reportId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->comment.read(iprot);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_addComment_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_addComment_args");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->reportId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->comment.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_addComment_pargs::~codeCheckerDBAccess_addComment_pargs() throw() {
}


uint32_t codeCheckerDBAccess_addComment_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_addComment_pargs");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->reportId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->comment)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_addComment_result::~codeCheckerDBAccess_addComment_result() throw() {
}


uint32_t codeCheckerDBAccess_addComment_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_addComment_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_addComment_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_addComment_presult::~codeCheckerDBAccess_addComment_presult() throw() {
}


uint32_t codeCheckerDBAccess_addComment_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_updateComment_args::~codeCheckerDBAccess_updateComment_args() throw() {
}


uint32_t codeCheckerDBAccess_updateComment_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->commentId);
          this->__isset.commentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newMessage);
          this->__isset.newMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_updateComment_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_updateComment_args");

  xfer += oprot->writeFieldBegin("commentId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->commentId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newMessage", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->newMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_updateComment_pargs::~codeCheckerDBAccess_updateComment_pargs() throw() {
}


uint32_t codeCheckerDBAccess_updateComment_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_updateComment_pargs");

  xfer += oprot->writeFieldBegin("commentId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->commentId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newMessage", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->newMessage)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_updateComment_result::~codeCheckerDBAccess_updateComment_result() throw() {
}


uint32_t codeCheckerDBAccess_updateComment_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_updateComment_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_updateComment_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_updateComment_presult::~codeCheckerDBAccess_updateComment_presult() throw() {
}


uint32_t codeCheckerDBAccess_updateComment_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_removeComment_args::~codeCheckerDBAccess_removeComment_args() throw() {
}


uint32_t codeCheckerDBAccess_removeComment_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->commentId);
          this->__isset.commentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeComment_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeComment_args");

  xfer += oprot->writeFieldBegin("commentId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->commentId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeComment_pargs::~codeCheckerDBAccess_removeComment_pargs() throw() {
}


uint32_t codeCheckerDBAccess_removeComment_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeComment_pargs");

  xfer += oprot->writeFieldBegin("commentId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->commentId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeComment_result::~codeCheckerDBAccess_removeComment_result() throw() {
}


uint32_t codeCheckerDBAccess_removeComment_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeComment_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeComment_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeComment_presult::~codeCheckerDBAccess_removeComment_presult() throw() {
}


uint32_t codeCheckerDBAccess_removeComment_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getCheckerDoc_args::~codeCheckerDBAccess_getCheckerDoc_args() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerDoc_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->checkerId);
          this->__isset.checkerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckerDoc_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerDoc_args");

  xfer += oprot->writeFieldBegin("checkerId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->checkerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerDoc_pargs::~codeCheckerDBAccess_getCheckerDoc_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerDoc_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerDoc_pargs");

  xfer += oprot->writeFieldBegin("checkerId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->checkerId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerDoc_result::~codeCheckerDBAccess_getCheckerDoc_result() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerDoc_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckerDoc_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerDoc_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerDoc_presult::~codeCheckerDBAccess_getCheckerDoc_presult() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerDoc_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getPackageVersion_args::~codeCheckerDBAccess_getPackageVersion_args() throw() {
}


uint32_t codeCheckerDBAccess_getPackageVersion_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getPackageVersion_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getPackageVersion_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getPackageVersion_pargs::~codeCheckerDBAccess_getPackageVersion_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getPackageVersion_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getPackageVersion_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getPackageVersion_result::~codeCheckerDBAccess_getPackageVersion_result() throw() {
}


uint32_t codeCheckerDBAccess_getPackageVersion_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getPackageVersion_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getPackageVersion_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getPackageVersion_presult::~codeCheckerDBAccess_getPackageVersion_presult() throw() {
}


uint32_t codeCheckerDBAccess_getPackageVersion_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_removeRunResults_args::~codeCheckerDBAccess_removeRunResults_args() throw() {
}


uint32_t codeCheckerDBAccess_removeRunResults_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size378;
            ::apache::thrift::protocol::TType _etype381;
            xfer += iprot->readListBegin(_etype381, _size378);
            this->runIds.resize(_size378);
            uint32_t _i382;
            for (_i382 = 0; _i382 < _size378; ++_i382)
            {
              xfer += iprot->readI64(this->runIds[_i382]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeRunResults_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRunResults_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter383;
    for (_iter383 = this->runIds.begin(); _iter383 != this->runIds.end(); ++_iter383)
    {
      xfer += oprot->writeI64((*_iter383));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRunResults_pargs::~codeCheckerDBAccess_removeRunResults_pargs() throw() {
}


uint32_t codeCheckerDBAccess_removeRunResults_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRunResults_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter384;
    for (_iter384 = (*(this->runIds)).begin(); _iter384 != (*(this->runIds)).end(); ++_iter384)
    {
      xfer += oprot->writeI64((*_iter384));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRunResults_result::~codeCheckerDBAccess_removeRunResults_result() throw() {
}


uint32_t codeCheckerDBAccess_removeRunResults_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeRunResults_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRunResults_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRunResults_presult::~codeCheckerDBAccess_removeRunResults_presult() throw() {
}


uint32_t codeCheckerDBAccess_removeRunResults_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_removeRunReports_args::~codeCheckerDBAccess_removeRunReports_args() throw() {
}


uint32_t codeCheckerDBAccess_removeRunReports_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size385;
            ::apache::thrift::protocol::TType _etype388;
            xfer += iprot->readListBegin(_etype388, _size385);
            this->runIds.resize(_size385);
            uint32_t _i389;
            for (_i389 = 0; _i389 < _size385; ++_i389)
            {
              xfer += iprot->readI64(this->runIds[_i389]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeRunReports_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRunReports_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter390;
    for (_iter390 = this->runIds.begin(); _iter390 != this->runIds.end(); ++_iter390)
    {
      xfer += oprot->writeI64((*_iter390));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRunReports_pargs::~codeCheckerDBAccess_removeRunReports_pargs() throw() {
}


uint32_t codeCheckerDBAccess_removeRunReports_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRunReports_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter391;
    for (_iter391 = (*(this->runIds)).begin(); _iter391 != (*(this->runIds)).end(); ++_iter391)
    {
      xfer += oprot->writeI64((*_iter391));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRunReports_result::~codeCheckerDBAccess_removeRunReports_result() throw() {
}


uint32_t codeCheckerDBAccess_removeRunReports_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeRunReports_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRunReports_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRunReports_presult::~codeCheckerDBAccess_removeRunReports_presult() throw() {
}


uint32_t codeCheckerDBAccess_removeRunReports_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_removeRun_args::~codeCheckerDBAccess_removeRun_args() throw() {
}


uint32_t codeCheckerDBAccess_removeRun_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->runId);
          this->__isset.runId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeRun_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRun_args");

  xfer += oprot->writeFieldBegin("runId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->runId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRun_pargs::~codeCheckerDBAccess_removeRun_pargs() throw() {
}


uint32_t codeCheckerDBAccess_removeRun_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRun_pargs");

  xfer += oprot->writeFieldBegin("runId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->runId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRun_result::~codeCheckerDBAccess_removeRun_result() throw() {
}


uint32_t codeCheckerDBAccess_removeRun_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeRun_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeRun_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeRun_presult::~codeCheckerDBAccess_removeRun_presult() throw() {
}


uint32_t codeCheckerDBAccess_removeRun_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getSuppressFile_args::~codeCheckerDBAccess_getSuppressFile_args() throw() {
}


uint32_t codeCheckerDBAccess_getSuppressFile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSuppressFile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSuppressFile_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSuppressFile_pargs::~codeCheckerDBAccess_getSuppressFile_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getSuppressFile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSuppressFile_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSuppressFile_result::~codeCheckerDBAccess_getSuppressFile_result() throw() {
}


uint32_t codeCheckerDBAccess_getSuppressFile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSuppressFile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSuppressFile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSuppressFile_presult::~codeCheckerDBAccess_getSuppressFile_presult() throw() {
}


uint32_t codeCheckerDBAccess_getSuppressFile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getSeverityCounts_args::~codeCheckerDBAccess_getSeverityCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getSeverityCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size392;
            ::apache::thrift::protocol::TType _etype395;
            xfer += iprot->readListBegin(_etype395, _size392);
            this->runIds.resize(_size392);
            uint32_t _i396;
            for (_i396 = 0; _i396 < _size392; ++_i396)
            {
              xfer += iprot->readI64(this->runIds[_i396]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSeverityCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSeverityCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter397;
    for (_iter397 = this->runIds.begin(); _iter397 != this->runIds.end(); ++_iter397)
    {
      xfer += oprot->writeI64((*_iter397));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSeverityCounts_pargs::~codeCheckerDBAccess_getSeverityCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getSeverityCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSeverityCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter398;
    for (_iter398 = (*(this->runIds)).begin(); _iter398 != (*(this->runIds)).end(); ++_iter398)
    {
      xfer += oprot->writeI64((*_iter398));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSeverityCounts_result::~codeCheckerDBAccess_getSeverityCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getSeverityCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size399;
            ::apache::thrift::protocol::TType _ktype400;
            ::apache::thrift::protocol::TType _vtype401;
            xfer += iprot->readMapBegin(_ktype400, _vtype401, _size399);
            uint32_t _i403;
            for (_i403 = 0; _i403 < _size399; ++_i403)
            {
              Severity::type _key404;
              int32_t ecast406;
              xfer += iprot->readI32(ecast406);
              _key404 = (Severity::type)ecast406;
              int64_t& _val405 = this->success[_key404];
              xfer += iprot->readI64(_val405);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSeverityCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSeverityCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::map<Severity::type, int64_t> ::const_iterator _iter407;
      for (_iter407 = this->success.begin(); _iter407 != this->success.end(); ++_iter407)
      {
        xfer += oprot->writeI32((int32_t)_iter407->first);
        xfer += oprot->writeI64(_iter407->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSeverityCounts_presult::~codeCheckerDBAccess_getSeverityCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getSeverityCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size408;
            ::apache::thrift::protocol::TType _ktype409;
            ::apache::thrift::protocol::TType _vtype410;
            xfer += iprot->readMapBegin(_ktype409, _vtype410, _size408);
            uint32_t _i412;
            for (_i412 = 0; _i412 < _size408; ++_i412)
            {
              Severity::type _key413;
              int32_t ecast415;
              xfer += iprot->readI32(ecast415);
              _key413 = (Severity::type)ecast415;
              int64_t& _val414 = (*(this->success))[_key413];
              xfer += iprot->readI64(_val414);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getCheckerMsgCounts_args::~codeCheckerDBAccess_getCheckerMsgCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerMsgCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size416;
            ::apache::thrift::protocol::TType _etype419;
            xfer += iprot->readListBegin(_etype419, _size416);
            this->runIds.resize(_size416);
            uint32_t _i420;
            for (_i420 = 0; _i420 < _size416; ++_i420)
            {
              xfer += iprot->readI64(this->runIds[_i420]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckerMsgCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerMsgCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter421;
    for (_iter421 = this->runIds.begin(); _iter421 != this->runIds.end(); ++_iter421)
    {
      xfer += oprot->writeI64((*_iter421));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerMsgCounts_pargs::~codeCheckerDBAccess_getCheckerMsgCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerMsgCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerMsgCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter422;
    for (_iter422 = (*(this->runIds)).begin(); _iter422 != (*(this->runIds)).end(); ++_iter422)
    {
      xfer += oprot->writeI64((*_iter422));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerMsgCounts_result::~codeCheckerDBAccess_getCheckerMsgCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerMsgCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size423;
            ::apache::thrift::protocol::TType _ktype424;
            ::apache::thrift::protocol::TType _vtype425;
            xfer += iprot->readMapBegin(_ktype424, _vtype425, _size423);
            uint32_t _i427;
            for (_i427 = 0; _i427 < _size423; ++_i427)
            {
              std::string _key428;
              xfer += iprot->readString(_key428);
              int64_t& _val429 = this->success[_key428];
              xfer += iprot->readI64(_val429);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckerMsgCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerMsgCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, int64_t> ::const_iterator _iter430;
      for (_iter430 = this->success.begin(); _iter430 != this->success.end(); ++_iter430)
      {
        xfer += oprot->writeString(_iter430->first);
        xfer += oprot->writeI64(_iter430->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerMsgCounts_presult::~codeCheckerDBAccess_getCheckerMsgCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerMsgCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size431;
            ::apache::thrift::protocol::TType _ktype432;
            ::apache::thrift::protocol::TType _vtype433;
            xfer += iprot->readMapBegin(_ktype432, _vtype433, _size431);
            uint32_t _i435;
            for (_i435 = 0; _i435 < _size431; ++_i435)
            {
              std::string _key436;
              xfer += iprot->readString(_key436);
              int64_t& _val437 = (*(this->success))[_key436];
              xfer += iprot->readI64(_val437);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getReviewStatusCounts_args::~codeCheckerDBAccess_getReviewStatusCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getReviewStatusCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size438;
            ::apache::thrift::protocol::TType _etype441;
            xfer += iprot->readListBegin(_etype441, _size438);
            this->runIds.resize(_size438);
            uint32_t _i442;
            for (_i442 = 0; _i442 < _size438; ++_i442)
            {
              xfer += iprot->readI64(this->runIds[_i442]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getReviewStatusCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReviewStatusCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter443;
    for (_iter443 = this->runIds.begin(); _iter443 != this->runIds.end(); ++_iter443)
    {
      xfer += oprot->writeI64((*_iter443));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReviewStatusCounts_pargs::~codeCheckerDBAccess_getReviewStatusCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getReviewStatusCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReviewStatusCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter444;
    for (_iter444 = (*(this->runIds)).begin(); _iter444 != (*(this->runIds)).end(); ++_iter444)
    {
      xfer += oprot->writeI64((*_iter444));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReviewStatusCounts_result::~codeCheckerDBAccess_getReviewStatusCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getReviewStatusCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size445;
            ::apache::thrift::protocol::TType _ktype446;
            ::apache::thrift::protocol::TType _vtype447;
            xfer += iprot->readMapBegin(_ktype446, _vtype447, _size445);
            uint32_t _i449;
            for (_i449 = 0; _i449 < _size445; ++_i449)
            {
              ReviewStatus::type _key450;
              int32_t ecast452;
              xfer += iprot->readI32(ecast452);
              _key450 = (ReviewStatus::type)ecast452;
              int64_t& _val451 = this->success[_key450];
              xfer += iprot->readI64(_val451);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getReviewStatusCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getReviewStatusCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::map<ReviewStatus::type, int64_t> ::const_iterator _iter453;
      for (_iter453 = this->success.begin(); _iter453 != this->success.end(); ++_iter453)
      {
        xfer += oprot->writeI32((int32_t)_iter453->first);
        xfer += oprot->writeI64(_iter453->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getReviewStatusCounts_presult::~codeCheckerDBAccess_getReviewStatusCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getReviewStatusCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size454;
            ::apache::thrift::protocol::TType _ktype455;
            ::apache::thrift::protocol::TType _vtype456;
            xfer += iprot->readMapBegin(_ktype455, _vtype456, _size454);
            uint32_t _i458;
            for (_i458 = 0; _i458 < _size454; ++_i458)
            {
              ReviewStatus::type _key459;
              int32_t ecast461;
              xfer += iprot->readI32(ecast461);
              _key459 = (ReviewStatus::type)ecast461;
              int64_t& _val460 = (*(this->success))[_key459];
              xfer += iprot->readI64(_val460);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getDetectionStatusCounts_args::~codeCheckerDBAccess_getDetectionStatusCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getDetectionStatusCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size462;
            ::apache::thrift::protocol::TType _etype465;
            xfer += iprot->readListBegin(_etype465, _size462);
            this->runIds.resize(_size462);
            uint32_t _i466;
            for (_i466 = 0; _i466 < _size462; ++_i466)
            {
              xfer += iprot->readI64(this->runIds[_i466]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getDetectionStatusCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getDetectionStatusCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter467;
    for (_iter467 = this->runIds.begin(); _iter467 != this->runIds.end(); ++_iter467)
    {
      xfer += oprot->writeI64((*_iter467));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getDetectionStatusCounts_pargs::~codeCheckerDBAccess_getDetectionStatusCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getDetectionStatusCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getDetectionStatusCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter468;
    for (_iter468 = (*(this->runIds)).begin(); _iter468 != (*(this->runIds)).end(); ++_iter468)
    {
      xfer += oprot->writeI64((*_iter468));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getDetectionStatusCounts_result::~codeCheckerDBAccess_getDetectionStatusCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getDetectionStatusCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size469;
            ::apache::thrift::protocol::TType _ktype470;
            ::apache::thrift::protocol::TType _vtype471;
            xfer += iprot->readMapBegin(_ktype470, _vtype471, _size469);
            uint32_t _i473;
            for (_i473 = 0; _i473 < _size469; ++_i473)
            {
              DetectionStatus::type _key474;
              int32_t ecast476;
              xfer += iprot->readI32(ecast476);
              _key474 = (DetectionStatus::type)ecast476;
              int64_t& _val475 = this->success[_key474];
              xfer += iprot->readI64(_val475);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getDetectionStatusCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getDetectionStatusCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::map<DetectionStatus::type, int64_t> ::const_iterator _iter477;
      for (_iter477 = this->success.begin(); _iter477 != this->success.end(); ++_iter477)
      {
        xfer += oprot->writeI32((int32_t)_iter477->first);
        xfer += oprot->writeI64(_iter477->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getDetectionStatusCounts_presult::~codeCheckerDBAccess_getDetectionStatusCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getDetectionStatusCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size478;
            ::apache::thrift::protocol::TType _ktype479;
            ::apache::thrift::protocol::TType _vtype480;
            xfer += iprot->readMapBegin(_ktype479, _vtype480, _size478);
            uint32_t _i482;
            for (_i482 = 0; _i482 < _size478; ++_i482)
            {
              DetectionStatus::type _key483;
              int32_t ecast485;
              xfer += iprot->readI32(ecast485);
              _key483 = (DetectionStatus::type)ecast485;
              int64_t& _val484 = (*(this->success))[_key483];
              xfer += iprot->readI64(_val484);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getFileCounts_args::~codeCheckerDBAccess_getFileCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getFileCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size486;
            ::apache::thrift::protocol::TType _etype489;
            xfer += iprot->readListBegin(_etype489, _size486);
            this->runIds.resize(_size486);
            uint32_t _i490;
            for (_i490 = 0; _i490 < _size486; ++_i490)
            {
              xfer += iprot->readI64(this->runIds[_i490]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getFileCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getFileCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter491;
    for (_iter491 = this->runIds.begin(); _iter491 != this->runIds.end(); ++_iter491)
    {
      xfer += oprot->writeI64((*_iter491));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getFileCounts_pargs::~codeCheckerDBAccess_getFileCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getFileCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getFileCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter492;
    for (_iter492 = (*(this->runIds)).begin(); _iter492 != (*(this->runIds)).end(); ++_iter492)
    {
      xfer += oprot->writeI64((*_iter492));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getFileCounts_result::~codeCheckerDBAccess_getFileCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getFileCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size493;
            ::apache::thrift::protocol::TType _ktype494;
            ::apache::thrift::protocol::TType _vtype495;
            xfer += iprot->readMapBegin(_ktype494, _vtype495, _size493);
            uint32_t _i497;
            for (_i497 = 0; _i497 < _size493; ++_i497)
            {
              std::string _key498;
              xfer += iprot->readString(_key498);
              int64_t& _val499 = this->success[_key498];
              xfer += iprot->readI64(_val499);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getFileCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getFileCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, int64_t> ::const_iterator _iter500;
      for (_iter500 = this->success.begin(); _iter500 != this->success.end(); ++_iter500)
      {
        xfer += oprot->writeString(_iter500->first);
        xfer += oprot->writeI64(_iter500->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getFileCounts_presult::~codeCheckerDBAccess_getFileCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getFileCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size501;
            ::apache::thrift::protocol::TType _ktype502;
            ::apache::thrift::protocol::TType _vtype503;
            xfer += iprot->readMapBegin(_ktype502, _vtype503, _size501);
            uint32_t _i505;
            for (_i505 = 0; _i505 < _size501; ++_i505)
            {
              std::string _key506;
              xfer += iprot->readString(_key506);
              int64_t& _val507 = (*(this->success))[_key506];
              xfer += iprot->readI64(_val507);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getCheckerCounts_args::~codeCheckerDBAccess_getCheckerCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size508;
            ::apache::thrift::protocol::TType _etype511;
            xfer += iprot->readListBegin(_etype511, _size508);
            this->runIds.resize(_size508);
            uint32_t _i512;
            for (_i512 = 0; _i512 < _size508; ++_i512)
            {
              xfer += iprot->readI64(this->runIds[_i512]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckerCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter513;
    for (_iter513 = this->runIds.begin(); _iter513 != this->runIds.end(); ++_iter513)
    {
      xfer += oprot->writeI64((*_iter513));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerCounts_pargs::~codeCheckerDBAccess_getCheckerCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter514;
    for (_iter514 = (*(this->runIds)).begin(); _iter514 != (*(this->runIds)).end(); ++_iter514)
    {
      xfer += oprot->writeI64((*_iter514));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->limit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerCounts_result::~codeCheckerDBAccess_getCheckerCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size515;
            ::apache::thrift::protocol::TType _etype518;
            xfer += iprot->readListBegin(_etype518, _size515);
            this->success.resize(_size515);
            uint32_t _i519;
            for (_i519 = 0; _i519 < _size515; ++_i519)
            {
              xfer += this->success[_i519].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getCheckerCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getCheckerCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<CheckerCount> ::const_iterator _iter520;
      for (_iter520 = this->success.begin(); _iter520 != this->success.end(); ++_iter520)
      {
        xfer += (*_iter520).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getCheckerCounts_presult::~codeCheckerDBAccess_getCheckerCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getCheckerCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size521;
            ::apache::thrift::protocol::TType _etype524;
            xfer += iprot->readListBegin(_etype524, _size521);
            (*(this->success)).resize(_size521);
            uint32_t _i525;
            for (_i525 = 0; _i525 < _size521; ++_i525)
            {
              xfer += (*(this->success))[_i525].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getRunHistoryTagCounts_args::~codeCheckerDBAccess_getRunHistoryTagCounts_args() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryTagCounts_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runIds.clear();
            uint32_t _size526;
            ::apache::thrift::protocol::TType _etype529;
            xfer += iprot->readListBegin(_etype529, _size526);
            this->runIds.resize(_size526);
            uint32_t _i530;
            for (_i530 = 0; _i530 < _size526; ++_i530)
            {
              xfer += iprot->readI64(this->runIds[_i530]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reportFilter.read(iprot);
          this->__isset.reportFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmpData.read(iprot);
          this->__isset.cmpData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunHistoryTagCounts_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistoryTagCounts_args");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->runIds.size()));
    std::vector<int64_t> ::const_iterator _iter531;
    for (_iter531 = this->runIds.begin(); _iter531 != this->runIds.end(); ++_iter531)
    {
      xfer += oprot->writeI64((*_iter531));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->reportFilter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cmpData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistoryTagCounts_pargs::~codeCheckerDBAccess_getRunHistoryTagCounts_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryTagCounts_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistoryTagCounts_pargs");

  xfer += oprot->writeFieldBegin("runIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->runIds)).size()));
    std::vector<int64_t> ::const_iterator _iter532;
    for (_iter532 = (*(this->runIds)).begin(); _iter532 != (*(this->runIds)).end(); ++_iter532)
    {
      xfer += oprot->writeI64((*_iter532));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportFilter", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->reportFilter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmpData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cmpData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistoryTagCounts_result::~codeCheckerDBAccess_getRunHistoryTagCounts_result() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryTagCounts_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size533;
            ::apache::thrift::protocol::TType _etype536;
            xfer += iprot->readListBegin(_etype536, _size533);
            this->success.resize(_size533);
            uint32_t _i537;
            for (_i537 = 0; _i537 < _size533; ++_i537)
            {
              xfer += this->success[_i537].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getRunHistoryTagCounts_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getRunHistoryTagCounts_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<RunTagCount> ::const_iterator _iter538;
      for (_iter538 = this->success.begin(); _iter538 != this->success.end(); ++_iter538)
      {
        xfer += (*_iter538).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getRunHistoryTagCounts_presult::~codeCheckerDBAccess_getRunHistoryTagCounts_presult() throw() {
}


uint32_t codeCheckerDBAccess_getRunHistoryTagCounts_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size539;
            ::apache::thrift::protocol::TType _etype542;
            xfer += iprot->readListBegin(_etype542, _size539);
            (*(this->success)).resize(_size539);
            uint32_t _i543;
            for (_i543 = 0; _i543 < _size539; ++_i543)
            {
              xfer += (*(this->success))[_i543].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_addSourceComponent_args::~codeCheckerDBAccess_addSourceComponent_args() throw() {
}


uint32_t codeCheckerDBAccess_addSourceComponent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_addSourceComponent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_addSourceComponent_args");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_addSourceComponent_pargs::~codeCheckerDBAccess_addSourceComponent_pargs() throw() {
}


uint32_t codeCheckerDBAccess_addSourceComponent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_addSourceComponent_pargs");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->description)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_addSourceComponent_result::~codeCheckerDBAccess_addSourceComponent_result() throw() {
}


uint32_t codeCheckerDBAccess_addSourceComponent_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_addSourceComponent_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_addSourceComponent_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_addSourceComponent_presult::~codeCheckerDBAccess_addSourceComponent_presult() throw() {
}


uint32_t codeCheckerDBAccess_addSourceComponent_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getSourceComponents_args::~codeCheckerDBAccess_getSourceComponents_args() throw() {
}


uint32_t codeCheckerDBAccess_getSourceComponents_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sourceComponentFilter.clear();
            uint32_t _size544;
            ::apache::thrift::protocol::TType _etype547;
            xfer += iprot->readListBegin(_etype547, _size544);
            this->sourceComponentFilter.resize(_size544);
            uint32_t _i548;
            for (_i548 = 0; _i548 < _size544; ++_i548)
            {
              xfer += iprot->readString(this->sourceComponentFilter[_i548]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sourceComponentFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSourceComponents_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSourceComponents_args");

  xfer += oprot->writeFieldBegin("sourceComponentFilter", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sourceComponentFilter.size()));
    std::vector<std::string> ::const_iterator _iter549;
    for (_iter549 = this->sourceComponentFilter.begin(); _iter549 != this->sourceComponentFilter.end(); ++_iter549)
    {
      xfer += oprot->writeString((*_iter549));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSourceComponents_pargs::~codeCheckerDBAccess_getSourceComponents_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getSourceComponents_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSourceComponents_pargs");

  xfer += oprot->writeFieldBegin("sourceComponentFilter", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->sourceComponentFilter)).size()));
    std::vector<std::string> ::const_iterator _iter550;
    for (_iter550 = (*(this->sourceComponentFilter)).begin(); _iter550 != (*(this->sourceComponentFilter)).end(); ++_iter550)
    {
      xfer += oprot->writeString((*_iter550));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSourceComponents_result::~codeCheckerDBAccess_getSourceComponents_result() throw() {
}


uint32_t codeCheckerDBAccess_getSourceComponents_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size551;
            ::apache::thrift::protocol::TType _etype554;
            xfer += iprot->readListBegin(_etype554, _size551);
            this->success.resize(_size551);
            uint32_t _i555;
            for (_i555 = 0; _i555 < _size551; ++_i555)
            {
              xfer += this->success[_i555].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getSourceComponents_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getSourceComponents_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<SourceComponentData> ::const_iterator _iter556;
      for (_iter556 = this->success.begin(); _iter556 != this->success.end(); ++_iter556)
      {
        xfer += (*_iter556).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getSourceComponents_presult::~codeCheckerDBAccess_getSourceComponents_presult() throw() {
}


uint32_t codeCheckerDBAccess_getSourceComponents_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size557;
            ::apache::thrift::protocol::TType _etype560;
            xfer += iprot->readListBegin(_etype560, _size557);
            (*(this->success)).resize(_size557);
            uint32_t _i561;
            for (_i561 = 0; _i561 < _size557; ++_i561)
            {
              xfer += (*(this->success))[_i561].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_removeSourceComponent_args::~codeCheckerDBAccess_removeSourceComponent_args() throw() {
}


uint32_t codeCheckerDBAccess_removeSourceComponent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeSourceComponent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeSourceComponent_args");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeSourceComponent_pargs::~codeCheckerDBAccess_removeSourceComponent_pargs() throw() {
}


uint32_t codeCheckerDBAccess_removeSourceComponent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeSourceComponent_pargs");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeSourceComponent_result::~codeCheckerDBAccess_removeSourceComponent_result() throw() {
}


uint32_t codeCheckerDBAccess_removeSourceComponent_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_removeSourceComponent_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_removeSourceComponent_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_removeSourceComponent_presult::~codeCheckerDBAccess_removeSourceComponent_presult() throw() {
}


uint32_t codeCheckerDBAccess_removeSourceComponent_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getMissingContentHashes_args::~codeCheckerDBAccess_getMissingContentHashes_args() throw() {
}


uint32_t codeCheckerDBAccess_getMissingContentHashes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileHashes.clear();
            uint32_t _size562;
            ::apache::thrift::protocol::TType _etype565;
            xfer += iprot->readListBegin(_etype565, _size562);
            this->fileHashes.resize(_size562);
            uint32_t _i566;
            for (_i566 = 0; _i566 < _size562; ++_i566)
            {
              xfer += iprot->readString(this->fileHashes[_i566]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fileHashes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getMissingContentHashes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getMissingContentHashes_args");

  xfer += oprot->writeFieldBegin("fileHashes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fileHashes.size()));
    std::vector<std::string> ::const_iterator _iter567;
    for (_iter567 = this->fileHashes.begin(); _iter567 != this->fileHashes.end(); ++_iter567)
    {
      xfer += oprot->writeString((*_iter567));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getMissingContentHashes_pargs::~codeCheckerDBAccess_getMissingContentHashes_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getMissingContentHashes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getMissingContentHashes_pargs");

  xfer += oprot->writeFieldBegin("fileHashes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fileHashes)).size()));
    std::vector<std::string> ::const_iterator _iter568;
    for (_iter568 = (*(this->fileHashes)).begin(); _iter568 != (*(this->fileHashes)).end(); ++_iter568)
    {
      xfer += oprot->writeString((*_iter568));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getMissingContentHashes_result::~codeCheckerDBAccess_getMissingContentHashes_result() throw() {
}


uint32_t codeCheckerDBAccess_getMissingContentHashes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size569;
            ::apache::thrift::protocol::TType _etype572;
            xfer += iprot->readListBegin(_etype572, _size569);
            this->success.resize(_size569);
            uint32_t _i573;
            for (_i573 = 0; _i573 < _size569; ++_i573)
            {
              xfer += iprot->readString(this->success[_i573]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getMissingContentHashes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getMissingContentHashes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter574;
      for (_iter574 = this->success.begin(); _iter574 != this->success.end(); ++_iter574)
      {
        xfer += oprot->writeString((*_iter574));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getMissingContentHashes_presult::~codeCheckerDBAccess_getMissingContentHashes_presult() throw() {
}


uint32_t codeCheckerDBAccess_getMissingContentHashes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size575;
            ::apache::thrift::protocol::TType _etype578;
            xfer += iprot->readListBegin(_etype578, _size575);
            (*(this->success)).resize(_size575);
            uint32_t _i579;
            for (_i579 = 0; _i579 < _size575; ++_i579)
            {
              xfer += iprot->readString((*(this->success))[_i579]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_massStoreRun_args::~codeCheckerDBAccess_massStoreRun_args() throw() {
}


uint32_t codeCheckerDBAccess_massStoreRun_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runName);
          this->__isset.runName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tag);
          this->__isset.tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zipfile);
          this->__isset.zipfile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->force);
          this->__isset.force = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->trimPathPrefixes.clear();
            uint32_t _size580;
            ::apache::thrift::protocol::TType _etype583;
            xfer += iprot->readListBegin(_etype583, _size580);
            this->trimPathPrefixes.resize(_size580);
            uint32_t _i584;
            for (_i584 = 0; _i584 < _size580; ++_i584)
            {
              xfer += iprot->readString(this->trimPathPrefixes[_i584]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.trimPathPrefixes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_massStoreRun_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_massStoreRun_args");

  xfer += oprot->writeFieldBegin("runName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->runName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zipfile", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->zipfile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("force", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->force);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trimPathPrefixes", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->trimPathPrefixes.size()));
    std::vector<std::string> ::const_iterator _iter585;
    for (_iter585 = this->trimPathPrefixes.begin(); _iter585 != this->trimPathPrefixes.end(); ++_iter585)
    {
      xfer += oprot->writeString((*_iter585));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_massStoreRun_pargs::~codeCheckerDBAccess_massStoreRun_pargs() throw() {
}


uint32_t codeCheckerDBAccess_massStoreRun_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_massStoreRun_pargs");

  xfer += oprot->writeFieldBegin("runName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->runName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tag)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->version)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zipfile", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->zipfile)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("force", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->force)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trimPathPrefixes", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->trimPathPrefixes)).size()));
    std::vector<std::string> ::const_iterator _iter586;
    for (_iter586 = (*(this->trimPathPrefixes)).begin(); _iter586 != (*(this->trimPathPrefixes)).end(); ++_iter586)
    {
      xfer += oprot->writeString((*_iter586));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_massStoreRun_result::~codeCheckerDBAccess_massStoreRun_result() throw() {
}


uint32_t codeCheckerDBAccess_massStoreRun_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_massStoreRun_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_massStoreRun_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_massStoreRun_presult::~codeCheckerDBAccess_massStoreRun_presult() throw() {
}


uint32_t codeCheckerDBAccess_massStoreRun_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_allowsStoringAnalysisStatistics_args::~codeCheckerDBAccess_allowsStoringAnalysisStatistics_args() throw() {
}


uint32_t codeCheckerDBAccess_allowsStoringAnalysisStatistics_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_allowsStoringAnalysisStatistics_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_allowsStoringAnalysisStatistics_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_allowsStoringAnalysisStatistics_pargs::~codeCheckerDBAccess_allowsStoringAnalysisStatistics_pargs() throw() {
}


uint32_t codeCheckerDBAccess_allowsStoringAnalysisStatistics_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_allowsStoringAnalysisStatistics_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_allowsStoringAnalysisStatistics_result::~codeCheckerDBAccess_allowsStoringAnalysisStatistics_result() throw() {
}


uint32_t codeCheckerDBAccess_allowsStoringAnalysisStatistics_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_allowsStoringAnalysisStatistics_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_allowsStoringAnalysisStatistics_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_allowsStoringAnalysisStatistics_presult::~codeCheckerDBAccess_allowsStoringAnalysisStatistics_presult() throw() {
}


uint32_t codeCheckerDBAccess_allowsStoringAnalysisStatistics_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getAnalysisStatisticsLimits_args::~codeCheckerDBAccess_getAnalysisStatisticsLimits_args() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatisticsLimits_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getAnalysisStatisticsLimits_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getAnalysisStatisticsLimits_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getAnalysisStatisticsLimits_pargs::~codeCheckerDBAccess_getAnalysisStatisticsLimits_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatisticsLimits_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getAnalysisStatisticsLimits_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getAnalysisStatisticsLimits_result::~codeCheckerDBAccess_getAnalysisStatisticsLimits_result() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatisticsLimits_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size587;
            ::apache::thrift::protocol::TType _ktype588;
            ::apache::thrift::protocol::TType _vtype589;
            xfer += iprot->readMapBegin(_ktype588, _vtype589, _size587);
            uint32_t _i591;
            for (_i591 = 0; _i591 < _size587; ++_i591)
            {
              StoreLimitKind::type _key592;
              int32_t ecast594;
              xfer += iprot->readI32(ecast594);
              _key592 = (StoreLimitKind::type)ecast594;
              int64_t& _val593 = this->success[_key592];
              xfer += iprot->readI64(_val593);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getAnalysisStatisticsLimits_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getAnalysisStatisticsLimits_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::map<StoreLimitKind::type, int64_t> ::const_iterator _iter595;
      for (_iter595 = this->success.begin(); _iter595 != this->success.end(); ++_iter595)
      {
        xfer += oprot->writeI32((int32_t)_iter595->first);
        xfer += oprot->writeI64(_iter595->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getAnalysisStatisticsLimits_presult::~codeCheckerDBAccess_getAnalysisStatisticsLimits_presult() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatisticsLimits_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size596;
            ::apache::thrift::protocol::TType _ktype597;
            ::apache::thrift::protocol::TType _vtype598;
            xfer += iprot->readMapBegin(_ktype597, _vtype598, _size596);
            uint32_t _i600;
            for (_i600 = 0; _i600 < _size596; ++_i600)
            {
              StoreLimitKind::type _key601;
              int32_t ecast603;
              xfer += iprot->readI32(ecast603);
              _key601 = (StoreLimitKind::type)ecast603;
              int64_t& _val602 = (*(this->success))[_key601];
              xfer += iprot->readI64(_val602);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_storeAnalysisStatistics_args::~codeCheckerDBAccess_storeAnalysisStatistics_args() throw() {
}


uint32_t codeCheckerDBAccess_storeAnalysisStatistics_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runName);
          this->__isset.runName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zipfile);
          this->__isset.zipfile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_storeAnalysisStatistics_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_storeAnalysisStatistics_args");

  xfer += oprot->writeFieldBegin("runName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->runName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zipfile", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->zipfile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_storeAnalysisStatistics_pargs::~codeCheckerDBAccess_storeAnalysisStatistics_pargs() throw() {
}


uint32_t codeCheckerDBAccess_storeAnalysisStatistics_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_storeAnalysisStatistics_pargs");

  xfer += oprot->writeFieldBegin("runName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->runName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zipfile", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->zipfile)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_storeAnalysisStatistics_result::~codeCheckerDBAccess_storeAnalysisStatistics_result() throw() {
}


uint32_t codeCheckerDBAccess_storeAnalysisStatistics_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_storeAnalysisStatistics_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_storeAnalysisStatistics_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_storeAnalysisStatistics_presult::~codeCheckerDBAccess_storeAnalysisStatistics_presult() throw() {
}


uint32_t codeCheckerDBAccess_storeAnalysisStatistics_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


codeCheckerDBAccess_getAnalysisStatistics_args::~codeCheckerDBAccess_getAnalysisStatistics_args() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatistics_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->runId);
          this->__isset.runId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->runHistoryId);
          this->__isset.runHistoryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getAnalysisStatistics_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getAnalysisStatistics_args");

  xfer += oprot->writeFieldBegin("runId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->runId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runHistoryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->runHistoryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getAnalysisStatistics_pargs::~codeCheckerDBAccess_getAnalysisStatistics_pargs() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatistics_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getAnalysisStatistics_pargs");

  xfer += oprot->writeFieldBegin("runId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->runId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runHistoryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->runHistoryId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getAnalysisStatistics_result::~codeCheckerDBAccess_getAnalysisStatistics_result() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatistics_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size604;
            ::apache::thrift::protocol::TType _ktype605;
            ::apache::thrift::protocol::TType _vtype606;
            xfer += iprot->readMapBegin(_ktype605, _vtype606, _size604);
            uint32_t _i608;
            for (_i608 = 0; _i608 < _size604; ++_i608)
            {
              AnalyzerType _key609;
              xfer += iprot->readString(_key609);
              AnalyzerStatistics& _val610 = this->success[_key609];
              xfer += _val610.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t codeCheckerDBAccess_getAnalysisStatistics_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("codeCheckerDBAccess_getAnalysisStatistics_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::map<AnalyzerType, AnalyzerStatistics> ::const_iterator _iter611;
      for (_iter611 = this->success.begin(); _iter611 != this->success.end(); ++_iter611)
      {
        xfer += oprot->writeString(_iter611->first);
        xfer += _iter611->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.requestError) {
    xfer += oprot->writeFieldBegin("requestError", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->requestError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


codeCheckerDBAccess_getAnalysisStatistics_presult::~codeCheckerDBAccess_getAnalysisStatistics_presult() throw() {
}


uint32_t codeCheckerDBAccess_getAnalysisStatistics_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size612;
            ::apache::thrift::protocol::TType _ktype613;
            ::apache::thrift::protocol::TType _vtype614;
            xfer += iprot->readMapBegin(_ktype613, _vtype614, _size612);
            uint32_t _i616;
            for (_i616 = 0; _i616 < _size612; ++_i616)
            {
              AnalyzerType _key617;
              xfer += iprot->readString(_key617);
              AnalyzerStatistics& _val618 = (*(this->success))[_key617];
              xfer += _val618.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestError.read(iprot);
          this->__isset.requestError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void codeCheckerDBAccessClient::getRunData(RunDataList& _return, const RunFilter& runFilter, const int64_t limit, const int64_t offset)
{
  send_getRunData(runFilter, limit, offset);
  recv_getRunData(_return);
}

void codeCheckerDBAccessClient::send_getRunData(const RunFilter& runFilter, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunData", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunData_pargs args;
  args.runFilter = &runFilter;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getRunData(RunDataList& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getRunData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunData failed: unknown result");
}

int64_t codeCheckerDBAccessClient::getRunCount(const RunFilter& runFilter)
{
  send_getRunCount(runFilter);
  return recv_getRunCount();
}

void codeCheckerDBAccessClient::send_getRunCount(const RunFilter& runFilter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunCount_pargs args;
  args.runFilter = &runFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t codeCheckerDBAccessClient::recv_getRunCount()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunCount") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  codeCheckerDBAccess_getRunCount_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunCount failed: unknown result");
}

void codeCheckerDBAccessClient::getCheckCommand(std::string& _return, const int64_t runHistoryId, const int64_t runId)
{
  send_getCheckCommand(runHistoryId, runId);
  recv_getCheckCommand(_return);
}

void codeCheckerDBAccessClient::send_getCheckCommand(const int64_t runHistoryId, const int64_t runId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getCheckCommand", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckCommand_pargs args;
  args.runHistoryId = &runHistoryId;
  args.runId = &runId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getCheckCommand(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getCheckCommand") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getCheckCommand_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckCommand failed: unknown result");
}

void codeCheckerDBAccessClient::getRunHistory(RunHistoryDataList& _return, const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const RunHistoryFilter& runHistoryFilter)
{
  send_getRunHistory(runIds, limit, offset, runHistoryFilter);
  recv_getRunHistory(_return);
}

void codeCheckerDBAccessClient::send_getRunHistory(const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const RunHistoryFilter& runHistoryFilter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunHistory_pargs args;
  args.runIds = &runIds;
  args.limit = &limit;
  args.offset = &offset;
  args.runHistoryFilter = &runHistoryFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getRunHistory(RunHistoryDataList& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunHistory") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getRunHistory_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunHistory failed: unknown result");
}

int64_t codeCheckerDBAccessClient::getRunHistoryCount(const std::vector<int64_t> & runIds, const RunHistoryFilter& runHistoryFilter)
{
  send_getRunHistoryCount(runIds, runHistoryFilter);
  return recv_getRunHistoryCount();
}

void codeCheckerDBAccessClient::send_getRunHistoryCount(const std::vector<int64_t> & runIds, const RunHistoryFilter& runHistoryFilter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunHistoryCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunHistoryCount_pargs args;
  args.runIds = &runIds;
  args.runHistoryFilter = &runHistoryFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t codeCheckerDBAccessClient::recv_getRunHistoryCount()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunHistoryCount") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  codeCheckerDBAccess_getRunHistoryCount_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunHistoryCount failed: unknown result");
}

void codeCheckerDBAccessClient::getDiffResultsHash(std::vector<std::string> & _return, const std::vector<int64_t> & runIds, const std::vector<std::string> & reportHashes, const DiffType::type diffType, const std::vector<DetectionStatus::type> & skipDetectionStatuses)
{
  send_getDiffResultsHash(runIds, reportHashes, diffType, skipDetectionStatuses);
  recv_getDiffResultsHash(_return);
}

void codeCheckerDBAccessClient::send_getDiffResultsHash(const std::vector<int64_t> & runIds, const std::vector<std::string> & reportHashes, const DiffType::type diffType, const std::vector<DetectionStatus::type> & skipDetectionStatuses)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getDiffResultsHash", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getDiffResultsHash_pargs args;
  args.runIds = &runIds;
  args.reportHashes = &reportHashes;
  args.diffType = &diffType;
  args.skipDetectionStatuses = &skipDetectionStatuses;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getDiffResultsHash(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getDiffResultsHash") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getDiffResultsHash_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDiffResultsHash failed: unknown result");
}

void codeCheckerDBAccessClient::getReport(ReportData& _return, const int64_t reportId)
{
  send_getReport(reportId);
  recv_getReport(_return);
}

void codeCheckerDBAccessClient::send_getReport(const int64_t reportId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getReport", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getReport_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getReport(ReportData& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getReport") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getReport_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getReport failed: unknown result");
}

void codeCheckerDBAccessClient::getRunResults(ReportDataList& _return, const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const std::vector<SortMode> & sortType, const ReportFilter& reportFilter, const CompareData& cmpData, const bool getDetails)
{
  send_getRunResults(runIds, limit, offset, sortType, reportFilter, cmpData, getDetails);
  recv_getRunResults(_return);
}

void codeCheckerDBAccessClient::send_getRunResults(const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const std::vector<SortMode> & sortType, const ReportFilter& reportFilter, const CompareData& cmpData, const bool getDetails)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunResults", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunResults_pargs args;
  args.runIds = &runIds;
  args.limit = &limit;
  args.offset = &offset;
  args.sortType = &sortType;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.getDetails = &getDetails;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getRunResults(ReportDataList& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunResults") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getRunResults_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunResults failed: unknown result");
}

void codeCheckerDBAccessClient::getRunReportCounts(RunReportCounts& _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const int64_t limit, const int64_t offset)
{
  send_getRunReportCounts(runIds, reportFilter, limit, offset);
  recv_getRunReportCounts(_return);
}

void codeCheckerDBAccessClient::send_getRunReportCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunReportCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunReportCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getRunReportCounts(RunReportCounts& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunReportCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getRunReportCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunReportCounts failed: unknown result");
}

int64_t codeCheckerDBAccessClient::getRunResultCount(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  send_getRunResultCount(runIds, reportFilter, cmpData);
  return recv_getRunResultCount();
}

void codeCheckerDBAccessClient::send_getRunResultCount(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunResultCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunResultCount_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t codeCheckerDBAccessClient::recv_getRunResultCount()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunResultCount") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  codeCheckerDBAccess_getRunResultCount_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunResultCount failed: unknown result");
}

void codeCheckerDBAccessClient::getReportDetails(ReportDetails& _return, const int64_t reportId)
{
  send_getReportDetails(reportId);
  recv_getReportDetails(_return);
}

void codeCheckerDBAccessClient::send_getReportDetails(const int64_t reportId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getReportDetails", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getReportDetails_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getReportDetails(ReportDetails& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getReportDetails") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getReportDetails_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getReportDetails failed: unknown result");
}

void codeCheckerDBAccessClient::getSourceFileData(SourceFileData& _return, const int64_t fileId, const bool fileContent, const Encoding::type encoding)
{
  send_getSourceFileData(fileId, fileContent, encoding);
  recv_getSourceFileData(_return);
}

void codeCheckerDBAccessClient::send_getSourceFileData(const int64_t fileId, const bool fileContent, const Encoding::type encoding)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSourceFileData", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSourceFileData_pargs args;
  args.fileId = &fileId;
  args.fileContent = &fileContent;
  args.encoding = &encoding;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getSourceFileData(SourceFileData& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSourceFileData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getSourceFileData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSourceFileData failed: unknown result");
}

void codeCheckerDBAccessClient::getLinesInSourceFileContents(std::map<int64_t, std::map<int64_t, std::string> > & _return, const LinesInFilesRequestedList& linesInFilesRequested, const Encoding::type encoding)
{
  send_getLinesInSourceFileContents(linesInFilesRequested, encoding);
  recv_getLinesInSourceFileContents(_return);
}

void codeCheckerDBAccessClient::send_getLinesInSourceFileContents(const LinesInFilesRequestedList& linesInFilesRequested, const Encoding::type encoding)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getLinesInSourceFileContents", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getLinesInSourceFileContents_pargs args;
  args.linesInFilesRequested = &linesInFilesRequested;
  args.encoding = &encoding;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getLinesInSourceFileContents(std::map<int64_t, std::map<int64_t, std::string> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getLinesInSourceFileContents") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getLinesInSourceFileContents_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getLinesInSourceFileContents failed: unknown result");
}

bool codeCheckerDBAccessClient::isReviewStatusChangeDisabled()
{
  send_isReviewStatusChangeDisabled();
  return recv_isReviewStatusChangeDisabled();
}

void codeCheckerDBAccessClient::send_isReviewStatusChangeDisabled()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("isReviewStatusChangeDisabled", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_isReviewStatusChangeDisabled_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_isReviewStatusChangeDisabled()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("isReviewStatusChangeDisabled") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_isReviewStatusChangeDisabled_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "isReviewStatusChangeDisabled failed: unknown result");
}

bool codeCheckerDBAccessClient::changeReviewStatus(const int64_t reportId, const ReviewStatus::type status, const std::string& message)
{
  send_changeReviewStatus(reportId, status, message);
  return recv_changeReviewStatus();
}

void codeCheckerDBAccessClient::send_changeReviewStatus(const int64_t reportId, const ReviewStatus::type status, const std::string& message)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("changeReviewStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_changeReviewStatus_pargs args;
  args.reportId = &reportId;
  args.status = &status;
  args.message = &message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_changeReviewStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("changeReviewStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_changeReviewStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "changeReviewStatus failed: unknown result");
}

void codeCheckerDBAccessClient::getComments(CommentDataList& _return, const int64_t reportId)
{
  send_getComments(reportId);
  recv_getComments(_return);
}

void codeCheckerDBAccessClient::send_getComments(const int64_t reportId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getComments", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getComments_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getComments(CommentDataList& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getComments") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getComments_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getComments failed: unknown result");
}

int64_t codeCheckerDBAccessClient::getCommentCount(const int64_t reportId)
{
  send_getCommentCount(reportId);
  return recv_getCommentCount();
}

void codeCheckerDBAccessClient::send_getCommentCount(const int64_t reportId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getCommentCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCommentCount_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t codeCheckerDBAccessClient::recv_getCommentCount()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getCommentCount") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  codeCheckerDBAccess_getCommentCount_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCommentCount failed: unknown result");
}

bool codeCheckerDBAccessClient::addComment(const int64_t reportId, const CommentData& comment)
{
  send_addComment(reportId, comment);
  return recv_addComment();
}

void codeCheckerDBAccessClient::send_addComment(const int64_t reportId, const CommentData& comment)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("addComment", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_addComment_pargs args;
  args.reportId = &reportId;
  args.comment = &comment;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_addComment()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("addComment") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_addComment_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "addComment failed: unknown result");
}

bool codeCheckerDBAccessClient::updateComment(const int64_t commentId, const std::string& newMessage)
{
  send_updateComment(commentId, newMessage);
  return recv_updateComment();
}

void codeCheckerDBAccessClient::send_updateComment(const int64_t commentId, const std::string& newMessage)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateComment", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_updateComment_pargs args;
  args.commentId = &commentId;
  args.newMessage = &newMessage;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_updateComment()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateComment") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_updateComment_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateComment failed: unknown result");
}

bool codeCheckerDBAccessClient::removeComment(const int64_t commentId)
{
  send_removeComment(commentId);
  return recv_removeComment();
}

void codeCheckerDBAccessClient::send_removeComment(const int64_t commentId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeComment", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeComment_pargs args;
  args.commentId = &commentId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_removeComment()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeComment") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_removeComment_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeComment failed: unknown result");
}

void codeCheckerDBAccessClient::getCheckerDoc(std::string& _return, const std::string& checkerId)
{
  send_getCheckerDoc(checkerId);
  recv_getCheckerDoc(_return);
}

void codeCheckerDBAccessClient::send_getCheckerDoc(const std::string& checkerId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getCheckerDoc", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckerDoc_pargs args;
  args.checkerId = &checkerId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getCheckerDoc(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getCheckerDoc") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getCheckerDoc_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckerDoc failed: unknown result");
}

void codeCheckerDBAccessClient::getPackageVersion(std::string& _return)
{
  send_getPackageVersion();
  recv_getPackageVersion(_return);
}

void codeCheckerDBAccessClient::send_getPackageVersion()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getPackageVersion", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getPackageVersion_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getPackageVersion(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getPackageVersion") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getPackageVersion_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getPackageVersion failed: unknown result");
}

bool codeCheckerDBAccessClient::removeRunResults(const std::vector<int64_t> & runIds)
{
  send_removeRunResults(runIds);
  return recv_removeRunResults();
}

void codeCheckerDBAccessClient::send_removeRunResults(const std::vector<int64_t> & runIds)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeRunResults", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeRunResults_pargs args;
  args.runIds = &runIds;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_removeRunResults()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeRunResults") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_removeRunResults_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeRunResults failed: unknown result");
}

bool codeCheckerDBAccessClient::removeRunReports(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  send_removeRunReports(runIds, reportFilter, cmpData);
  return recv_removeRunReports();
}

void codeCheckerDBAccessClient::send_removeRunReports(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeRunReports", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeRunReports_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_removeRunReports()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeRunReports") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_removeRunReports_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeRunReports failed: unknown result");
}

bool codeCheckerDBAccessClient::removeRun(const int64_t runId)
{
  send_removeRun(runId);
  return recv_removeRun();
}

void codeCheckerDBAccessClient::send_removeRun(const int64_t runId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeRun", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeRun_pargs args;
  args.runId = &runId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_removeRun()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeRun") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_removeRun_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeRun failed: unknown result");
}

void codeCheckerDBAccessClient::getSuppressFile(std::string& _return)
{
  send_getSuppressFile();
  recv_getSuppressFile(_return);
}

void codeCheckerDBAccessClient::send_getSuppressFile()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSuppressFile", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSuppressFile_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getSuppressFile(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSuppressFile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getSuppressFile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSuppressFile failed: unknown result");
}

void codeCheckerDBAccessClient::getSeverityCounts(std::map<Severity::type, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  send_getSeverityCounts(runIds, reportFilter, cmpData);
  recv_getSeverityCounts(_return);
}

void codeCheckerDBAccessClient::send_getSeverityCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSeverityCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSeverityCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getSeverityCounts(std::map<Severity::type, int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSeverityCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getSeverityCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSeverityCounts failed: unknown result");
}

void codeCheckerDBAccessClient::getCheckerMsgCounts(std::map<std::string, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  send_getCheckerMsgCounts(runIds, reportFilter, cmpData, limit, offset);
  recv_getCheckerMsgCounts(_return);
}

void codeCheckerDBAccessClient::send_getCheckerMsgCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getCheckerMsgCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckerMsgCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getCheckerMsgCounts(std::map<std::string, int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getCheckerMsgCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getCheckerMsgCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckerMsgCounts failed: unknown result");
}

void codeCheckerDBAccessClient::getReviewStatusCounts(std::map<ReviewStatus::type, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  send_getReviewStatusCounts(runIds, reportFilter, cmpData);
  recv_getReviewStatusCounts(_return);
}

void codeCheckerDBAccessClient::send_getReviewStatusCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getReviewStatusCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getReviewStatusCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getReviewStatusCounts(std::map<ReviewStatus::type, int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getReviewStatusCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getReviewStatusCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getReviewStatusCounts failed: unknown result");
}

void codeCheckerDBAccessClient::getDetectionStatusCounts(std::map<DetectionStatus::type, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  send_getDetectionStatusCounts(runIds, reportFilter, cmpData);
  recv_getDetectionStatusCounts(_return);
}

void codeCheckerDBAccessClient::send_getDetectionStatusCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getDetectionStatusCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getDetectionStatusCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getDetectionStatusCounts(std::map<DetectionStatus::type, int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getDetectionStatusCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getDetectionStatusCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDetectionStatusCounts failed: unknown result");
}

void codeCheckerDBAccessClient::getFileCounts(std::map<std::string, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  send_getFileCounts(runIds, reportFilter, cmpData, limit, offset);
  recv_getFileCounts(_return);
}

void codeCheckerDBAccessClient::send_getFileCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getFileCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getFileCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getFileCounts(std::map<std::string, int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getFileCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getFileCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getFileCounts failed: unknown result");
}

void codeCheckerDBAccessClient::getCheckerCounts(CheckerCounts& _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  send_getCheckerCounts(runIds, reportFilter, cmpData, limit, offset);
  recv_getCheckerCounts(_return);
}

void codeCheckerDBAccessClient::send_getCheckerCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getCheckerCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckerCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getCheckerCounts(CheckerCounts& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getCheckerCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getCheckerCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckerCounts failed: unknown result");
}

void codeCheckerDBAccessClient::getRunHistoryTagCounts(RunTagCounts& _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  send_getRunHistoryTagCounts(runIds, reportFilter, cmpData);
  recv_getRunHistoryTagCounts(_return);
}

void codeCheckerDBAccessClient::send_getRunHistoryTagCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getRunHistoryTagCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunHistoryTagCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getRunHistoryTagCounts(RunTagCounts& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getRunHistoryTagCounts") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getRunHistoryTagCounts_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunHistoryTagCounts failed: unknown result");
}

bool codeCheckerDBAccessClient::addSourceComponent(const std::string& name, const std::string& value, const std::string& description)
{
  send_addSourceComponent(name, value, description);
  return recv_addSourceComponent();
}

void codeCheckerDBAccessClient::send_addSourceComponent(const std::string& name, const std::string& value, const std::string& description)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("addSourceComponent", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_addSourceComponent_pargs args;
  args.name = &name;
  args.value = &value;
  args.description = &description;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_addSourceComponent()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("addSourceComponent") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_addSourceComponent_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "addSourceComponent failed: unknown result");
}

void codeCheckerDBAccessClient::getSourceComponents(SourceComponentDataList& _return, const std::vector<std::string> & sourceComponentFilter)
{
  send_getSourceComponents(sourceComponentFilter);
  recv_getSourceComponents(_return);
}

void codeCheckerDBAccessClient::send_getSourceComponents(const std::vector<std::string> & sourceComponentFilter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSourceComponents", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSourceComponents_pargs args;
  args.sourceComponentFilter = &sourceComponentFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getSourceComponents(SourceComponentDataList& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSourceComponents") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getSourceComponents_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSourceComponents failed: unknown result");
}

bool codeCheckerDBAccessClient::removeSourceComponent(const std::string& name)
{
  send_removeSourceComponent(name);
  return recv_removeSourceComponent();
}

void codeCheckerDBAccessClient::send_removeSourceComponent(const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeSourceComponent", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeSourceComponent_pargs args;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_removeSourceComponent()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeSourceComponent") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_removeSourceComponent_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeSourceComponent failed: unknown result");
}

void codeCheckerDBAccessClient::getMissingContentHashes(std::vector<std::string> & _return, const std::vector<std::string> & fileHashes)
{
  send_getMissingContentHashes(fileHashes);
  recv_getMissingContentHashes(_return);
}

void codeCheckerDBAccessClient::send_getMissingContentHashes(const std::vector<std::string> & fileHashes)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getMissingContentHashes", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getMissingContentHashes_pargs args;
  args.fileHashes = &fileHashes;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getMissingContentHashes(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getMissingContentHashes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getMissingContentHashes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getMissingContentHashes failed: unknown result");
}

int64_t codeCheckerDBAccessClient::massStoreRun(const std::string& runName, const std::string& tag, const std::string& version, const std::string& zipfile, const bool force, const std::vector<std::string> & trimPathPrefixes)
{
  send_massStoreRun(runName, tag, version, zipfile, force, trimPathPrefixes);
  return recv_massStoreRun();
}

void codeCheckerDBAccessClient::send_massStoreRun(const std::string& runName, const std::string& tag, const std::string& version, const std::string& zipfile, const bool force, const std::vector<std::string> & trimPathPrefixes)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("massStoreRun", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_massStoreRun_pargs args;
  args.runName = &runName;
  args.tag = &tag;
  args.version = &version;
  args.zipfile = &zipfile;
  args.force = &force;
  args.trimPathPrefixes = &trimPathPrefixes;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t codeCheckerDBAccessClient::recv_massStoreRun()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("massStoreRun") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  codeCheckerDBAccess_massStoreRun_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "massStoreRun failed: unknown result");
}

bool codeCheckerDBAccessClient::allowsStoringAnalysisStatistics()
{
  send_allowsStoringAnalysisStatistics();
  return recv_allowsStoringAnalysisStatistics();
}

void codeCheckerDBAccessClient::send_allowsStoringAnalysisStatistics()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("allowsStoringAnalysisStatistics", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_allowsStoringAnalysisStatistics_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_allowsStoringAnalysisStatistics()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("allowsStoringAnalysisStatistics") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_allowsStoringAnalysisStatistics_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "allowsStoringAnalysisStatistics failed: unknown result");
}

void codeCheckerDBAccessClient::getAnalysisStatisticsLimits(std::map<StoreLimitKind::type, int64_t> & _return)
{
  send_getAnalysisStatisticsLimits();
  recv_getAnalysisStatisticsLimits(_return);
}

void codeCheckerDBAccessClient::send_getAnalysisStatisticsLimits()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getAnalysisStatisticsLimits", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getAnalysisStatisticsLimits_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getAnalysisStatisticsLimits(std::map<StoreLimitKind::type, int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getAnalysisStatisticsLimits") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getAnalysisStatisticsLimits_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAnalysisStatisticsLimits failed: unknown result");
}

bool codeCheckerDBAccessClient::storeAnalysisStatistics(const std::string& runName, const std::string& zipfile)
{
  send_storeAnalysisStatistics(runName, zipfile);
  return recv_storeAnalysisStatistics();
}

void codeCheckerDBAccessClient::send_storeAnalysisStatistics(const std::string& runName, const std::string& zipfile)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("storeAnalysisStatistics", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_storeAnalysisStatistics_pargs args;
  args.runName = &runName;
  args.zipfile = &zipfile;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool codeCheckerDBAccessClient::recv_storeAnalysisStatistics()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("storeAnalysisStatistics") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  codeCheckerDBAccess_storeAnalysisStatistics_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "storeAnalysisStatistics failed: unknown result");
}

void codeCheckerDBAccessClient::getAnalysisStatistics(AnalyzerStatisticsData& _return, const int64_t runId, const int64_t runHistoryId)
{
  send_getAnalysisStatistics(runId, runHistoryId);
  recv_getAnalysisStatistics(_return);
}

void codeCheckerDBAccessClient::send_getAnalysisStatistics(const int64_t runId, const int64_t runHistoryId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getAnalysisStatistics", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getAnalysisStatistics_pargs args;
  args.runId = &runId;
  args.runHistoryId = &runHistoryId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void codeCheckerDBAccessClient::recv_getAnalysisStatistics(AnalyzerStatisticsData& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getAnalysisStatistics") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  codeCheckerDBAccess_getAnalysisStatistics_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.requestError) {
    throw result.requestError;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAnalysisStatistics failed: unknown result");
}

bool codeCheckerDBAccessProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void codeCheckerDBAccessProcessor::process_getRunData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunData");
  }

  codeCheckerDBAccess_getRunData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunData", bytes);
  }

  codeCheckerDBAccess_getRunData_result result;
  try {
    iface_->getRunData(result.success, args.runFilter, args.limit, args.offset);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunData");
  }

  oprot->writeMessageBegin("getRunData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunData", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getRunCount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunCount", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunCount");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunCount");
  }

  codeCheckerDBAccess_getRunCount_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunCount", bytes);
  }

  codeCheckerDBAccess_getRunCount_result result;
  try {
    result.success = iface_->getRunCount(args.runFilter);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunCount");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunCount", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunCount");
  }

  oprot->writeMessageBegin("getRunCount", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunCount", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getCheckCommand(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getCheckCommand", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getCheckCommand");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getCheckCommand");
  }

  codeCheckerDBAccess_getCheckCommand_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getCheckCommand", bytes);
  }

  codeCheckerDBAccess_getCheckCommand_result result;
  try {
    iface_->getCheckCommand(result.success, args.runHistoryId, args.runId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getCheckCommand");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getCheckCommand", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getCheckCommand");
  }

  oprot->writeMessageBegin("getCheckCommand", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getCheckCommand", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getRunHistory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunHistory", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunHistory");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunHistory");
  }

  codeCheckerDBAccess_getRunHistory_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunHistory", bytes);
  }

  codeCheckerDBAccess_getRunHistory_result result;
  try {
    iface_->getRunHistory(result.success, args.runIds, args.limit, args.offset, args.runHistoryFilter);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunHistory");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunHistory", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunHistory");
  }

  oprot->writeMessageBegin("getRunHistory", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunHistory", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getRunHistoryCount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunHistoryCount", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunHistoryCount");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunHistoryCount");
  }

  codeCheckerDBAccess_getRunHistoryCount_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunHistoryCount", bytes);
  }

  codeCheckerDBAccess_getRunHistoryCount_result result;
  try {
    result.success = iface_->getRunHistoryCount(args.runIds, args.runHistoryFilter);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunHistoryCount");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunHistoryCount", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunHistoryCount");
  }

  oprot->writeMessageBegin("getRunHistoryCount", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunHistoryCount", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getDiffResultsHash(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getDiffResultsHash", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getDiffResultsHash");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getDiffResultsHash");
  }

  codeCheckerDBAccess_getDiffResultsHash_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getDiffResultsHash", bytes);
  }

  codeCheckerDBAccess_getDiffResultsHash_result result;
  try {
    iface_->getDiffResultsHash(result.success, args.runIds, args.reportHashes, args.diffType, args.skipDetectionStatuses);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getDiffResultsHash");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getDiffResultsHash", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getDiffResultsHash");
  }

  oprot->writeMessageBegin("getDiffResultsHash", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getDiffResultsHash", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getReport(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getReport", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getReport");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getReport");
  }

  codeCheckerDBAccess_getReport_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getReport", bytes);
  }

  codeCheckerDBAccess_getReport_result result;
  try {
    iface_->getReport(result.success, args.reportId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getReport");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getReport", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getReport");
  }

  oprot->writeMessageBegin("getReport", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getReport", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getRunResults(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunResults", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunResults");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunResults");
  }

  codeCheckerDBAccess_getRunResults_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunResults", bytes);
  }

  codeCheckerDBAccess_getRunResults_result result;
  try {
    iface_->getRunResults(result.success, args.runIds, args.limit, args.offset, args.sortType, args.reportFilter, args.cmpData, args.getDetails);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunResults");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunResults", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunResults");
  }

  oprot->writeMessageBegin("getRunResults", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunResults", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getRunReportCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunReportCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunReportCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunReportCounts");
  }

  codeCheckerDBAccess_getRunReportCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunReportCounts", bytes);
  }

  codeCheckerDBAccess_getRunReportCounts_result result;
  try {
    iface_->getRunReportCounts(result.success, args.runIds, args.reportFilter, args.limit, args.offset);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunReportCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunReportCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunReportCounts");
  }

  oprot->writeMessageBegin("getRunReportCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunReportCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getRunResultCount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunResultCount", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunResultCount");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunResultCount");
  }

  codeCheckerDBAccess_getRunResultCount_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunResultCount", bytes);
  }

  codeCheckerDBAccess_getRunResultCount_result result;
  try {
    result.success = iface_->getRunResultCount(args.runIds, args.reportFilter, args.cmpData);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunResultCount");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunResultCount", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunResultCount");
  }

  oprot->writeMessageBegin("getRunResultCount", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunResultCount", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getReportDetails(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getReportDetails", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getReportDetails");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getReportDetails");
  }

  codeCheckerDBAccess_getReportDetails_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getReportDetails", bytes);
  }

  codeCheckerDBAccess_getReportDetails_result result;
  try {
    iface_->getReportDetails(result.success, args.reportId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getReportDetails");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getReportDetails", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getReportDetails");
  }

  oprot->writeMessageBegin("getReportDetails", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getReportDetails", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getSourceFileData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getSourceFileData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getSourceFileData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getSourceFileData");
  }

  codeCheckerDBAccess_getSourceFileData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getSourceFileData", bytes);
  }

  codeCheckerDBAccess_getSourceFileData_result result;
  try {
    iface_->getSourceFileData(result.success, args.fileId, args.fileContent, args.encoding);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getSourceFileData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSourceFileData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getSourceFileData");
  }

  oprot->writeMessageBegin("getSourceFileData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getSourceFileData", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getLinesInSourceFileContents(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getLinesInSourceFileContents", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getLinesInSourceFileContents");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getLinesInSourceFileContents");
  }

  codeCheckerDBAccess_getLinesInSourceFileContents_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getLinesInSourceFileContents", bytes);
  }

  codeCheckerDBAccess_getLinesInSourceFileContents_result result;
  try {
    iface_->getLinesInSourceFileContents(result.success, args.linesInFilesRequested, args.encoding);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getLinesInSourceFileContents");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getLinesInSourceFileContents", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getLinesInSourceFileContents");
  }

  oprot->writeMessageBegin("getLinesInSourceFileContents", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getLinesInSourceFileContents", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_isReviewStatusChangeDisabled(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.isReviewStatusChangeDisabled", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.isReviewStatusChangeDisabled");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.isReviewStatusChangeDisabled");
  }

  codeCheckerDBAccess_isReviewStatusChangeDisabled_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.isReviewStatusChangeDisabled", bytes);
  }

  codeCheckerDBAccess_isReviewStatusChangeDisabled_result result;
  try {
    result.success = iface_->isReviewStatusChangeDisabled();
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.isReviewStatusChangeDisabled");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("isReviewStatusChangeDisabled", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.isReviewStatusChangeDisabled");
  }

  oprot->writeMessageBegin("isReviewStatusChangeDisabled", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.isReviewStatusChangeDisabled", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_changeReviewStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.changeReviewStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.changeReviewStatus");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.changeReviewStatus");
  }

  codeCheckerDBAccess_changeReviewStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.changeReviewStatus", bytes);
  }

  codeCheckerDBAccess_changeReviewStatus_result result;
  try {
    result.success = iface_->changeReviewStatus(args.reportId, args.status, args.message);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.changeReviewStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("changeReviewStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.changeReviewStatus");
  }

  oprot->writeMessageBegin("changeReviewStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.changeReviewStatus", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getComments(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getComments", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getComments");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getComments");
  }

  codeCheckerDBAccess_getComments_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getComments", bytes);
  }

  codeCheckerDBAccess_getComments_result result;
  try {
    iface_->getComments(result.success, args.reportId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getComments");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getComments", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getComments");
  }

  oprot->writeMessageBegin("getComments", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getComments", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getCommentCount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getCommentCount", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getCommentCount");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getCommentCount");
  }

  codeCheckerDBAccess_getCommentCount_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getCommentCount", bytes);
  }

  codeCheckerDBAccess_getCommentCount_result result;
  try {
    result.success = iface_->getCommentCount(args.reportId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getCommentCount");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getCommentCount", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getCommentCount");
  }

  oprot->writeMessageBegin("getCommentCount", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getCommentCount", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_addComment(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.addComment", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.addComment");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.addComment");
  }

  codeCheckerDBAccess_addComment_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.addComment", bytes);
  }

  codeCheckerDBAccess_addComment_result result;
  try {
    result.success = iface_->addComment(args.reportId, args.comment);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.addComment");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("addComment", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.addComment");
  }

  oprot->writeMessageBegin("addComment", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.addComment", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_updateComment(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.updateComment", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.updateComment");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.updateComment");
  }

  codeCheckerDBAccess_updateComment_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.updateComment", bytes);
  }

  codeCheckerDBAccess_updateComment_result result;
  try {
    result.success = iface_->updateComment(args.commentId, args.newMessage);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.updateComment");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateComment", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.updateComment");
  }

  oprot->writeMessageBegin("updateComment", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.updateComment", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_removeComment(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.removeComment", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.removeComment");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.removeComment");
  }

  codeCheckerDBAccess_removeComment_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.removeComment", bytes);
  }

  codeCheckerDBAccess_removeComment_result result;
  try {
    result.success = iface_->removeComment(args.commentId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.removeComment");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeComment", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.removeComment");
  }

  oprot->writeMessageBegin("removeComment", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.removeComment", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getCheckerDoc(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getCheckerDoc", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getCheckerDoc");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getCheckerDoc");
  }

  codeCheckerDBAccess_getCheckerDoc_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getCheckerDoc", bytes);
  }

  codeCheckerDBAccess_getCheckerDoc_result result;
  try {
    iface_->getCheckerDoc(result.success, args.checkerId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getCheckerDoc");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getCheckerDoc", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getCheckerDoc");
  }

  oprot->writeMessageBegin("getCheckerDoc", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getCheckerDoc", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getPackageVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getPackageVersion", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getPackageVersion");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getPackageVersion");
  }

  codeCheckerDBAccess_getPackageVersion_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getPackageVersion", bytes);
  }

  codeCheckerDBAccess_getPackageVersion_result result;
  try {
    iface_->getPackageVersion(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getPackageVersion");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getPackageVersion", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getPackageVersion");
  }

  oprot->writeMessageBegin("getPackageVersion", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getPackageVersion", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_removeRunResults(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.removeRunResults", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.removeRunResults");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.removeRunResults");
  }

  codeCheckerDBAccess_removeRunResults_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.removeRunResults", bytes);
  }

  codeCheckerDBAccess_removeRunResults_result result;
  try {
    result.success = iface_->removeRunResults(args.runIds);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.removeRunResults");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeRunResults", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.removeRunResults");
  }

  oprot->writeMessageBegin("removeRunResults", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.removeRunResults", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_removeRunReports(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.removeRunReports", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.removeRunReports");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.removeRunReports");
  }

  codeCheckerDBAccess_removeRunReports_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.removeRunReports", bytes);
  }

  codeCheckerDBAccess_removeRunReports_result result;
  try {
    result.success = iface_->removeRunReports(args.runIds, args.reportFilter, args.cmpData);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.removeRunReports");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeRunReports", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.removeRunReports");
  }

  oprot->writeMessageBegin("removeRunReports", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.removeRunReports", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_removeRun(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.removeRun", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.removeRun");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.removeRun");
  }

  codeCheckerDBAccess_removeRun_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.removeRun", bytes);
  }

  codeCheckerDBAccess_removeRun_result result;
  try {
    result.success = iface_->removeRun(args.runId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.removeRun");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeRun", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.removeRun");
  }

  oprot->writeMessageBegin("removeRun", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.removeRun", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getSuppressFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getSuppressFile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getSuppressFile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getSuppressFile");
  }

  codeCheckerDBAccess_getSuppressFile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getSuppressFile", bytes);
  }

  codeCheckerDBAccess_getSuppressFile_result result;
  try {
    iface_->getSuppressFile(result.success);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getSuppressFile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSuppressFile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getSuppressFile");
  }

  oprot->writeMessageBegin("getSuppressFile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getSuppressFile", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getSeverityCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getSeverityCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getSeverityCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getSeverityCounts");
  }

  codeCheckerDBAccess_getSeverityCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getSeverityCounts", bytes);
  }

  codeCheckerDBAccess_getSeverityCounts_result result;
  try {
    iface_->getSeverityCounts(result.success, args.runIds, args.reportFilter, args.cmpData);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getSeverityCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSeverityCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getSeverityCounts");
  }

  oprot->writeMessageBegin("getSeverityCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getSeverityCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getCheckerMsgCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getCheckerMsgCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getCheckerMsgCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getCheckerMsgCounts");
  }

  codeCheckerDBAccess_getCheckerMsgCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getCheckerMsgCounts", bytes);
  }

  codeCheckerDBAccess_getCheckerMsgCounts_result result;
  try {
    iface_->getCheckerMsgCounts(result.success, args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getCheckerMsgCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getCheckerMsgCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getCheckerMsgCounts");
  }

  oprot->writeMessageBegin("getCheckerMsgCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getCheckerMsgCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getReviewStatusCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getReviewStatusCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getReviewStatusCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getReviewStatusCounts");
  }

  codeCheckerDBAccess_getReviewStatusCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getReviewStatusCounts", bytes);
  }

  codeCheckerDBAccess_getReviewStatusCounts_result result;
  try {
    iface_->getReviewStatusCounts(result.success, args.runIds, args.reportFilter, args.cmpData);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getReviewStatusCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getReviewStatusCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getReviewStatusCounts");
  }

  oprot->writeMessageBegin("getReviewStatusCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getReviewStatusCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getDetectionStatusCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getDetectionStatusCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getDetectionStatusCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getDetectionStatusCounts");
  }

  codeCheckerDBAccess_getDetectionStatusCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getDetectionStatusCounts", bytes);
  }

  codeCheckerDBAccess_getDetectionStatusCounts_result result;
  try {
    iface_->getDetectionStatusCounts(result.success, args.runIds, args.reportFilter, args.cmpData);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getDetectionStatusCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getDetectionStatusCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getDetectionStatusCounts");
  }

  oprot->writeMessageBegin("getDetectionStatusCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getDetectionStatusCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getFileCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getFileCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getFileCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getFileCounts");
  }

  codeCheckerDBAccess_getFileCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getFileCounts", bytes);
  }

  codeCheckerDBAccess_getFileCounts_result result;
  try {
    iface_->getFileCounts(result.success, args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getFileCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getFileCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getFileCounts");
  }

  oprot->writeMessageBegin("getFileCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getFileCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getCheckerCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getCheckerCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getCheckerCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getCheckerCounts");
  }

  codeCheckerDBAccess_getCheckerCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getCheckerCounts", bytes);
  }

  codeCheckerDBAccess_getCheckerCounts_result result;
  try {
    iface_->getCheckerCounts(result.success, args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getCheckerCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getCheckerCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getCheckerCounts");
  }

  oprot->writeMessageBegin("getCheckerCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getCheckerCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getRunHistoryTagCounts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getRunHistoryTagCounts", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getRunHistoryTagCounts");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getRunHistoryTagCounts");
  }

  codeCheckerDBAccess_getRunHistoryTagCounts_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getRunHistoryTagCounts", bytes);
  }

  codeCheckerDBAccess_getRunHistoryTagCounts_result result;
  try {
    iface_->getRunHistoryTagCounts(result.success, args.runIds, args.reportFilter, args.cmpData);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getRunHistoryTagCounts");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getRunHistoryTagCounts", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getRunHistoryTagCounts");
  }

  oprot->writeMessageBegin("getRunHistoryTagCounts", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getRunHistoryTagCounts", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_addSourceComponent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.addSourceComponent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.addSourceComponent");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.addSourceComponent");
  }

  codeCheckerDBAccess_addSourceComponent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.addSourceComponent", bytes);
  }

  codeCheckerDBAccess_addSourceComponent_result result;
  try {
    result.success = iface_->addSourceComponent(args.name, args.value, args.description);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.addSourceComponent");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("addSourceComponent", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.addSourceComponent");
  }

  oprot->writeMessageBegin("addSourceComponent", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.addSourceComponent", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getSourceComponents(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getSourceComponents", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getSourceComponents");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getSourceComponents");
  }

  codeCheckerDBAccess_getSourceComponents_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getSourceComponents", bytes);
  }

  codeCheckerDBAccess_getSourceComponents_result result;
  try {
    iface_->getSourceComponents(result.success, args.sourceComponentFilter);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getSourceComponents");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSourceComponents", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getSourceComponents");
  }

  oprot->writeMessageBegin("getSourceComponents", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getSourceComponents", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_removeSourceComponent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.removeSourceComponent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.removeSourceComponent");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.removeSourceComponent");
  }

  codeCheckerDBAccess_removeSourceComponent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.removeSourceComponent", bytes);
  }

  codeCheckerDBAccess_removeSourceComponent_result result;
  try {
    result.success = iface_->removeSourceComponent(args.name);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.removeSourceComponent");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeSourceComponent", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.removeSourceComponent");
  }

  oprot->writeMessageBegin("removeSourceComponent", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.removeSourceComponent", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getMissingContentHashes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getMissingContentHashes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getMissingContentHashes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getMissingContentHashes");
  }

  codeCheckerDBAccess_getMissingContentHashes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getMissingContentHashes", bytes);
  }

  codeCheckerDBAccess_getMissingContentHashes_result result;
  try {
    iface_->getMissingContentHashes(result.success, args.fileHashes);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getMissingContentHashes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getMissingContentHashes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getMissingContentHashes");
  }

  oprot->writeMessageBegin("getMissingContentHashes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getMissingContentHashes", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_massStoreRun(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.massStoreRun", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.massStoreRun");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.massStoreRun");
  }

  codeCheckerDBAccess_massStoreRun_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.massStoreRun", bytes);
  }

  codeCheckerDBAccess_massStoreRun_result result;
  try {
    result.success = iface_->massStoreRun(args.runName, args.tag, args.version, args.zipfile, args.force, args.trimPathPrefixes);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.massStoreRun");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("massStoreRun", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.massStoreRun");
  }

  oprot->writeMessageBegin("massStoreRun", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.massStoreRun", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_allowsStoringAnalysisStatistics(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.allowsStoringAnalysisStatistics", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.allowsStoringAnalysisStatistics");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.allowsStoringAnalysisStatistics");
  }

  codeCheckerDBAccess_allowsStoringAnalysisStatistics_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.allowsStoringAnalysisStatistics", bytes);
  }

  codeCheckerDBAccess_allowsStoringAnalysisStatistics_result result;
  try {
    result.success = iface_->allowsStoringAnalysisStatistics();
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.allowsStoringAnalysisStatistics");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("allowsStoringAnalysisStatistics", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.allowsStoringAnalysisStatistics");
  }

  oprot->writeMessageBegin("allowsStoringAnalysisStatistics", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.allowsStoringAnalysisStatistics", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getAnalysisStatisticsLimits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getAnalysisStatisticsLimits", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getAnalysisStatisticsLimits");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getAnalysisStatisticsLimits");
  }

  codeCheckerDBAccess_getAnalysisStatisticsLimits_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getAnalysisStatisticsLimits", bytes);
  }

  codeCheckerDBAccess_getAnalysisStatisticsLimits_result result;
  try {
    iface_->getAnalysisStatisticsLimits(result.success);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getAnalysisStatisticsLimits");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getAnalysisStatisticsLimits", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getAnalysisStatisticsLimits");
  }

  oprot->writeMessageBegin("getAnalysisStatisticsLimits", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getAnalysisStatisticsLimits", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_storeAnalysisStatistics(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.storeAnalysisStatistics", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.storeAnalysisStatistics");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.storeAnalysisStatistics");
  }

  codeCheckerDBAccess_storeAnalysisStatistics_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.storeAnalysisStatistics", bytes);
  }

  codeCheckerDBAccess_storeAnalysisStatistics_result result;
  try {
    result.success = iface_->storeAnalysisStatistics(args.runName, args.zipfile);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.storeAnalysisStatistics");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("storeAnalysisStatistics", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.storeAnalysisStatistics");
  }

  oprot->writeMessageBegin("storeAnalysisStatistics", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.storeAnalysisStatistics", bytes);
  }
}

void codeCheckerDBAccessProcessor::process_getAnalysisStatistics(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("codeCheckerDBAccess.getAnalysisStatistics", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "codeCheckerDBAccess.getAnalysisStatistics");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "codeCheckerDBAccess.getAnalysisStatistics");
  }

  codeCheckerDBAccess_getAnalysisStatistics_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "codeCheckerDBAccess.getAnalysisStatistics", bytes);
  }

  codeCheckerDBAccess_getAnalysisStatistics_result result;
  try {
    iface_->getAnalysisStatistics(result.success, args.runId, args.runHistoryId);
    result.__isset.success = true;
  } catch ( ::RequestFailed &requestError) {
    result.requestError = requestError;
    result.__isset.requestError = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "codeCheckerDBAccess.getAnalysisStatistics");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getAnalysisStatistics", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "codeCheckerDBAccess.getAnalysisStatistics");
  }

  oprot->writeMessageBegin("getAnalysisStatistics", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "codeCheckerDBAccess.getAnalysisStatistics", bytes);
  }
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > codeCheckerDBAccessProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< codeCheckerDBAccessIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< codeCheckerDBAccessIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new codeCheckerDBAccessProcessor(handler));
  return processor;
}

void codeCheckerDBAccessConcurrentClient::getRunData(RunDataList& _return, const RunFilter& runFilter, const int64_t limit, const int64_t offset)
{
  int32_t seqid = send_getRunData(runFilter, limit, offset);
  recv_getRunData(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunData(const RunFilter& runFilter, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunData", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunData_pargs args;
  args.runFilter = &runFilter;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getRunData(RunDataList& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getRunData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t codeCheckerDBAccessConcurrentClient::getRunCount(const RunFilter& runFilter)
{
  int32_t seqid = send_getRunCount(runFilter);
  return recv_getRunCount(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunCount(const RunFilter& runFilter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunCount_pargs args;
  args.runFilter = &runFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t codeCheckerDBAccessConcurrentClient::recv_getRunCount(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunCount") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      codeCheckerDBAccess_getRunCount_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunCount failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getCheckCommand(std::string& _return, const int64_t runHistoryId, const int64_t runId)
{
  int32_t seqid = send_getCheckCommand(runHistoryId, runId);
  recv_getCheckCommand(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getCheckCommand(const int64_t runHistoryId, const int64_t runId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getCheckCommand", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckCommand_pargs args;
  args.runHistoryId = &runHistoryId;
  args.runId = &runId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getCheckCommand(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getCheckCommand") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getCheckCommand_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckCommand failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getRunHistory(RunHistoryDataList& _return, const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const RunHistoryFilter& runHistoryFilter)
{
  int32_t seqid = send_getRunHistory(runIds, limit, offset, runHistoryFilter);
  recv_getRunHistory(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunHistory(const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const RunHistoryFilter& runHistoryFilter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunHistory_pargs args;
  args.runIds = &runIds;
  args.limit = &limit;
  args.offset = &offset;
  args.runHistoryFilter = &runHistoryFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getRunHistory(RunHistoryDataList& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunHistory") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getRunHistory_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunHistory failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t codeCheckerDBAccessConcurrentClient::getRunHistoryCount(const std::vector<int64_t> & runIds, const RunHistoryFilter& runHistoryFilter)
{
  int32_t seqid = send_getRunHistoryCount(runIds, runHistoryFilter);
  return recv_getRunHistoryCount(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunHistoryCount(const std::vector<int64_t> & runIds, const RunHistoryFilter& runHistoryFilter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunHistoryCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunHistoryCount_pargs args;
  args.runIds = &runIds;
  args.runHistoryFilter = &runHistoryFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t codeCheckerDBAccessConcurrentClient::recv_getRunHistoryCount(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunHistoryCount") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      codeCheckerDBAccess_getRunHistoryCount_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunHistoryCount failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getDiffResultsHash(std::vector<std::string> & _return, const std::vector<int64_t> & runIds, const std::vector<std::string> & reportHashes, const DiffType::type diffType, const std::vector<DetectionStatus::type> & skipDetectionStatuses)
{
  int32_t seqid = send_getDiffResultsHash(runIds, reportHashes, diffType, skipDetectionStatuses);
  recv_getDiffResultsHash(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getDiffResultsHash(const std::vector<int64_t> & runIds, const std::vector<std::string> & reportHashes, const DiffType::type diffType, const std::vector<DetectionStatus::type> & skipDetectionStatuses)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getDiffResultsHash", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getDiffResultsHash_pargs args;
  args.runIds = &runIds;
  args.reportHashes = &reportHashes;
  args.diffType = &diffType;
  args.skipDetectionStatuses = &skipDetectionStatuses;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getDiffResultsHash(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getDiffResultsHash") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getDiffResultsHash_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDiffResultsHash failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getReport(ReportData& _return, const int64_t reportId)
{
  int32_t seqid = send_getReport(reportId);
  recv_getReport(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getReport(const int64_t reportId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getReport", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getReport_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getReport(ReportData& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getReport") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getReport_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getReport failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getRunResults(ReportDataList& _return, const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const std::vector<SortMode> & sortType, const ReportFilter& reportFilter, const CompareData& cmpData, const bool getDetails)
{
  int32_t seqid = send_getRunResults(runIds, limit, offset, sortType, reportFilter, cmpData, getDetails);
  recv_getRunResults(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunResults(const std::vector<int64_t> & runIds, const int64_t limit, const int64_t offset, const std::vector<SortMode> & sortType, const ReportFilter& reportFilter, const CompareData& cmpData, const bool getDetails)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunResults", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunResults_pargs args;
  args.runIds = &runIds;
  args.limit = &limit;
  args.offset = &offset;
  args.sortType = &sortType;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.getDetails = &getDetails;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getRunResults(ReportDataList& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunResults") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getRunResults_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunResults failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getRunReportCounts(RunReportCounts& _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const int64_t limit, const int64_t offset)
{
  int32_t seqid = send_getRunReportCounts(runIds, reportFilter, limit, offset);
  recv_getRunReportCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunReportCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunReportCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunReportCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getRunReportCounts(RunReportCounts& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunReportCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getRunReportCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunReportCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t codeCheckerDBAccessConcurrentClient::getRunResultCount(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t seqid = send_getRunResultCount(runIds, reportFilter, cmpData);
  return recv_getRunResultCount(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunResultCount(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunResultCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunResultCount_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t codeCheckerDBAccessConcurrentClient::recv_getRunResultCount(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunResultCount") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      codeCheckerDBAccess_getRunResultCount_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunResultCount failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getReportDetails(ReportDetails& _return, const int64_t reportId)
{
  int32_t seqid = send_getReportDetails(reportId);
  recv_getReportDetails(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getReportDetails(const int64_t reportId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getReportDetails", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getReportDetails_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getReportDetails(ReportDetails& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getReportDetails") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getReportDetails_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getReportDetails failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getSourceFileData(SourceFileData& _return, const int64_t fileId, const bool fileContent, const Encoding::type encoding)
{
  int32_t seqid = send_getSourceFileData(fileId, fileContent, encoding);
  recv_getSourceFileData(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getSourceFileData(const int64_t fileId, const bool fileContent, const Encoding::type encoding)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getSourceFileData", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSourceFileData_pargs args;
  args.fileId = &fileId;
  args.fileContent = &fileContent;
  args.encoding = &encoding;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getSourceFileData(SourceFileData& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getSourceFileData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getSourceFileData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSourceFileData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getLinesInSourceFileContents(std::map<int64_t, std::map<int64_t, std::string> > & _return, const LinesInFilesRequestedList& linesInFilesRequested, const Encoding::type encoding)
{
  int32_t seqid = send_getLinesInSourceFileContents(linesInFilesRequested, encoding);
  recv_getLinesInSourceFileContents(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getLinesInSourceFileContents(const LinesInFilesRequestedList& linesInFilesRequested, const Encoding::type encoding)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getLinesInSourceFileContents", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getLinesInSourceFileContents_pargs args;
  args.linesInFilesRequested = &linesInFilesRequested;
  args.encoding = &encoding;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getLinesInSourceFileContents(std::map<int64_t, std::map<int64_t, std::string> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getLinesInSourceFileContents") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getLinesInSourceFileContents_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getLinesInSourceFileContents failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::isReviewStatusChangeDisabled()
{
  int32_t seqid = send_isReviewStatusChangeDisabled();
  return recv_isReviewStatusChangeDisabled(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_isReviewStatusChangeDisabled()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("isReviewStatusChangeDisabled", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_isReviewStatusChangeDisabled_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_isReviewStatusChangeDisabled(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("isReviewStatusChangeDisabled") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_isReviewStatusChangeDisabled_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "isReviewStatusChangeDisabled failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::changeReviewStatus(const int64_t reportId, const ReviewStatus::type status, const std::string& message)
{
  int32_t seqid = send_changeReviewStatus(reportId, status, message);
  return recv_changeReviewStatus(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_changeReviewStatus(const int64_t reportId, const ReviewStatus::type status, const std::string& message)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("changeReviewStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_changeReviewStatus_pargs args;
  args.reportId = &reportId;
  args.status = &status;
  args.message = &message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_changeReviewStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("changeReviewStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_changeReviewStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "changeReviewStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getComments(CommentDataList& _return, const int64_t reportId)
{
  int32_t seqid = send_getComments(reportId);
  recv_getComments(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getComments(const int64_t reportId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getComments", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getComments_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getComments(CommentDataList& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getComments") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getComments_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getComments failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t codeCheckerDBAccessConcurrentClient::getCommentCount(const int64_t reportId)
{
  int32_t seqid = send_getCommentCount(reportId);
  return recv_getCommentCount(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getCommentCount(const int64_t reportId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getCommentCount", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCommentCount_pargs args;
  args.reportId = &reportId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t codeCheckerDBAccessConcurrentClient::recv_getCommentCount(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getCommentCount") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      codeCheckerDBAccess_getCommentCount_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCommentCount failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::addComment(const int64_t reportId, const CommentData& comment)
{
  int32_t seqid = send_addComment(reportId, comment);
  return recv_addComment(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_addComment(const int64_t reportId, const CommentData& comment)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("addComment", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_addComment_pargs args;
  args.reportId = &reportId;
  args.comment = &comment;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_addComment(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("addComment") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_addComment_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "addComment failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::updateComment(const int64_t commentId, const std::string& newMessage)
{
  int32_t seqid = send_updateComment(commentId, newMessage);
  return recv_updateComment(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_updateComment(const int64_t commentId, const std::string& newMessage)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("updateComment", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_updateComment_pargs args;
  args.commentId = &commentId;
  args.newMessage = &newMessage;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_updateComment(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("updateComment") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_updateComment_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateComment failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::removeComment(const int64_t commentId)
{
  int32_t seqid = send_removeComment(commentId);
  return recv_removeComment(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_removeComment(const int64_t commentId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("removeComment", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeComment_pargs args;
  args.commentId = &commentId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_removeComment(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("removeComment") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_removeComment_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeComment failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getCheckerDoc(std::string& _return, const std::string& checkerId)
{
  int32_t seqid = send_getCheckerDoc(checkerId);
  recv_getCheckerDoc(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getCheckerDoc(const std::string& checkerId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getCheckerDoc", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckerDoc_pargs args;
  args.checkerId = &checkerId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getCheckerDoc(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getCheckerDoc") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getCheckerDoc_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckerDoc failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getPackageVersion(std::string& _return)
{
  int32_t seqid = send_getPackageVersion();
  recv_getPackageVersion(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getPackageVersion()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getPackageVersion", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getPackageVersion_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getPackageVersion(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getPackageVersion") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getPackageVersion_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getPackageVersion failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::removeRunResults(const std::vector<int64_t> & runIds)
{
  int32_t seqid = send_removeRunResults(runIds);
  return recv_removeRunResults(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_removeRunResults(const std::vector<int64_t> & runIds)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("removeRunResults", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeRunResults_pargs args;
  args.runIds = &runIds;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_removeRunResults(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("removeRunResults") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_removeRunResults_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeRunResults failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::removeRunReports(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t seqid = send_removeRunReports(runIds, reportFilter, cmpData);
  return recv_removeRunReports(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_removeRunReports(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("removeRunReports", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeRunReports_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_removeRunReports(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("removeRunReports") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_removeRunReports_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeRunReports failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::removeRun(const int64_t runId)
{
  int32_t seqid = send_removeRun(runId);
  return recv_removeRun(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_removeRun(const int64_t runId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("removeRun", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeRun_pargs args;
  args.runId = &runId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_removeRun(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("removeRun") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_removeRun_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeRun failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getSuppressFile(std::string& _return)
{
  int32_t seqid = send_getSuppressFile();
  recv_getSuppressFile(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getSuppressFile()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getSuppressFile", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSuppressFile_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getSuppressFile(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getSuppressFile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getSuppressFile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSuppressFile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getSeverityCounts(std::map<Severity::type, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t seqid = send_getSeverityCounts(runIds, reportFilter, cmpData);
  recv_getSeverityCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getSeverityCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getSeverityCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSeverityCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getSeverityCounts(std::map<Severity::type, int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getSeverityCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getSeverityCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSeverityCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getCheckerMsgCounts(std::map<std::string, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t seqid = send_getCheckerMsgCounts(runIds, reportFilter, cmpData, limit, offset);
  recv_getCheckerMsgCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getCheckerMsgCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getCheckerMsgCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckerMsgCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getCheckerMsgCounts(std::map<std::string, int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getCheckerMsgCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getCheckerMsgCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckerMsgCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getReviewStatusCounts(std::map<ReviewStatus::type, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t seqid = send_getReviewStatusCounts(runIds, reportFilter, cmpData);
  recv_getReviewStatusCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getReviewStatusCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getReviewStatusCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getReviewStatusCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getReviewStatusCounts(std::map<ReviewStatus::type, int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getReviewStatusCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getReviewStatusCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getReviewStatusCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getDetectionStatusCounts(std::map<DetectionStatus::type, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t seqid = send_getDetectionStatusCounts(runIds, reportFilter, cmpData);
  recv_getDetectionStatusCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getDetectionStatusCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getDetectionStatusCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getDetectionStatusCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getDetectionStatusCounts(std::map<DetectionStatus::type, int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getDetectionStatusCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getDetectionStatusCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDetectionStatusCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getFileCounts(std::map<std::string, int64_t> & _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t seqid = send_getFileCounts(runIds, reportFilter, cmpData, limit, offset);
  recv_getFileCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getFileCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getFileCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getFileCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getFileCounts(std::map<std::string, int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getFileCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getFileCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getFileCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getCheckerCounts(CheckerCounts& _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t seqid = send_getCheckerCounts(runIds, reportFilter, cmpData, limit, offset);
  recv_getCheckerCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getCheckerCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData, const int64_t limit, const int64_t offset)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getCheckerCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getCheckerCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.limit = &limit;
  args.offset = &offset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getCheckerCounts(CheckerCounts& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getCheckerCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getCheckerCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getCheckerCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getRunHistoryTagCounts(RunTagCounts& _return, const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t seqid = send_getRunHistoryTagCounts(runIds, reportFilter, cmpData);
  recv_getRunHistoryTagCounts(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getRunHistoryTagCounts(const std::vector<int64_t> & runIds, const ReportFilter& reportFilter, const CompareData& cmpData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getRunHistoryTagCounts", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getRunHistoryTagCounts_pargs args;
  args.runIds = &runIds;
  args.reportFilter = &reportFilter;
  args.cmpData = &cmpData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getRunHistoryTagCounts(RunTagCounts& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getRunHistoryTagCounts") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getRunHistoryTagCounts_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getRunHistoryTagCounts failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::addSourceComponent(const std::string& name, const std::string& value, const std::string& description)
{
  int32_t seqid = send_addSourceComponent(name, value, description);
  return recv_addSourceComponent(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_addSourceComponent(const std::string& name, const std::string& value, const std::string& description)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("addSourceComponent", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_addSourceComponent_pargs args;
  args.name = &name;
  args.value = &value;
  args.description = &description;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_addSourceComponent(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("addSourceComponent") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_addSourceComponent_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "addSourceComponent failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getSourceComponents(SourceComponentDataList& _return, const std::vector<std::string> & sourceComponentFilter)
{
  int32_t seqid = send_getSourceComponents(sourceComponentFilter);
  recv_getSourceComponents(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getSourceComponents(const std::vector<std::string> & sourceComponentFilter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getSourceComponents", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getSourceComponents_pargs args;
  args.sourceComponentFilter = &sourceComponentFilter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getSourceComponents(SourceComponentDataList& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getSourceComponents") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getSourceComponents_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSourceComponents failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::removeSourceComponent(const std::string& name)
{
  int32_t seqid = send_removeSourceComponent(name);
  return recv_removeSourceComponent(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_removeSourceComponent(const std::string& name)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("removeSourceComponent", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_removeSourceComponent_pargs args;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_removeSourceComponent(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("removeSourceComponent") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_removeSourceComponent_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeSourceComponent failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getMissingContentHashes(std::vector<std::string> & _return, const std::vector<std::string> & fileHashes)
{
  int32_t seqid = send_getMissingContentHashes(fileHashes);
  recv_getMissingContentHashes(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getMissingContentHashes(const std::vector<std::string> & fileHashes)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getMissingContentHashes", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getMissingContentHashes_pargs args;
  args.fileHashes = &fileHashes;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getMissingContentHashes(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getMissingContentHashes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getMissingContentHashes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getMissingContentHashes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t codeCheckerDBAccessConcurrentClient::massStoreRun(const std::string& runName, const std::string& tag, const std::string& version, const std::string& zipfile, const bool force, const std::vector<std::string> & trimPathPrefixes)
{
  int32_t seqid = send_massStoreRun(runName, tag, version, zipfile, force, trimPathPrefixes);
  return recv_massStoreRun(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_massStoreRun(const std::string& runName, const std::string& tag, const std::string& version, const std::string& zipfile, const bool force, const std::vector<std::string> & trimPathPrefixes)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("massStoreRun", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_massStoreRun_pargs args;
  args.runName = &runName;
  args.tag = &tag;
  args.version = &version;
  args.zipfile = &zipfile;
  args.force = &force;
  args.trimPathPrefixes = &trimPathPrefixes;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t codeCheckerDBAccessConcurrentClient::recv_massStoreRun(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("massStoreRun") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      codeCheckerDBAccess_massStoreRun_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "massStoreRun failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::allowsStoringAnalysisStatistics()
{
  int32_t seqid = send_allowsStoringAnalysisStatistics();
  return recv_allowsStoringAnalysisStatistics(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_allowsStoringAnalysisStatistics()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("allowsStoringAnalysisStatistics", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_allowsStoringAnalysisStatistics_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_allowsStoringAnalysisStatistics(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("allowsStoringAnalysisStatistics") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_allowsStoringAnalysisStatistics_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "allowsStoringAnalysisStatistics failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getAnalysisStatisticsLimits(std::map<StoreLimitKind::type, int64_t> & _return)
{
  int32_t seqid = send_getAnalysisStatisticsLimits();
  recv_getAnalysisStatisticsLimits(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getAnalysisStatisticsLimits()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getAnalysisStatisticsLimits", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getAnalysisStatisticsLimits_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getAnalysisStatisticsLimits(std::map<StoreLimitKind::type, int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getAnalysisStatisticsLimits") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getAnalysisStatisticsLimits_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAnalysisStatisticsLimits failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool codeCheckerDBAccessConcurrentClient::storeAnalysisStatistics(const std::string& runName, const std::string& zipfile)
{
  int32_t seqid = send_storeAnalysisStatistics(runName, zipfile);
  return recv_storeAnalysisStatistics(seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_storeAnalysisStatistics(const std::string& runName, const std::string& zipfile)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("storeAnalysisStatistics", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_storeAnalysisStatistics_pargs args;
  args.runName = &runName;
  args.zipfile = &zipfile;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool codeCheckerDBAccessConcurrentClient::recv_storeAnalysisStatistics(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("storeAnalysisStatistics") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      codeCheckerDBAccess_storeAnalysisStatistics_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "storeAnalysisStatistics failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void codeCheckerDBAccessConcurrentClient::getAnalysisStatistics(AnalyzerStatisticsData& _return, const int64_t runId, const int64_t runHistoryId)
{
  int32_t seqid = send_getAnalysisStatistics(runId, runHistoryId);
  recv_getAnalysisStatistics(_return, seqid);
}

int32_t codeCheckerDBAccessConcurrentClient::send_getAnalysisStatistics(const int64_t runId, const int64_t runHistoryId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getAnalysisStatistics", ::apache::thrift::protocol::T_CALL, cseqid);

  codeCheckerDBAccess_getAnalysisStatistics_pargs args;
  args.runId = &runId;
  args.runHistoryId = &runHistoryId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void codeCheckerDBAccessConcurrentClient::recv_getAnalysisStatistics(AnalyzerStatisticsData& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getAnalysisStatistics") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      codeCheckerDBAccess_getAnalysisStatistics_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.requestError) {
        sentry.commit();
        throw result.requestError;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAnalysisStatistics failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}



